% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fmrilm.R, R/fmrilm_new.R
\name{fmri_lm}
\alias{fmri_lm}
\title{Fit a Linear Regression Model for fMRI Data Analysis}
\usage{
fmri_lm(
  formula,
  block,
  baseline_model = NULL,
  dataset,
  durations = 0,
  drop_empty = TRUE,
  strategy = c("runwise", "chunkwise"),
  nchunks = 10,
  robust = c(FALSE, "huber", "bisquare"),
  robust_options = NULL,
  ar_options = NULL,
  extra_nuisance = NULL,
  keep_extra_nuisance_in_model = FALSE,
  use_fast_path = FALSE,
  verbose = FALSE,
  progress = FALSE
)

fmri_lm(
  formula,
  block,
  baseline_model = NULL,
  dataset,
  durations = 0,
  drop_empty = TRUE,
  strategy = c("runwise", "chunkwise"),
  nchunks = 10,
  robust = c(FALSE, "huber", "bisquare"),
  robust_options = NULL,
  ar_options = NULL,
  extra_nuisance = NULL,
  keep_extra_nuisance_in_model = FALSE,
  use_fast_path = FALSE,
  verbose = FALSE,
  progress = FALSE
)
}
\arguments{
\item{formula}{A formula specifying the linear model to fit to the fMRI data}

\item{block}{A factor or character vector indicating the block structure}

\item{baseline_model}{An optional baseline model object}

\item{dataset}{An fmri_dataset object containing the fMRI data}

\item{durations}{Event durations (default 0 for impulse events)}

\item{drop_empty}{Drop empty factor levels from block}

\item{strategy}{The fitting strategy: "runwise" or "chunkwise"}

\item{nchunks}{Number of data chunks for "chunkwise" strategy}

\item{robust}{Robust regression method: FALSE (none), "huber", or "bisquare"}

\item{robust_options}{List of robust fitting options or NULL to use defaults}

\item{ar_options}{List of AR modeling options or NULL to use defaults}

\item{extra_nuisance}{Additional nuisance regressors (NULL, matrix, or formula)}

\item{keep_extra_nuisance_in_model}{Whether to include extra nuisance in the model}

\item{use_fast_path}{Use optimized matrix computations}

\item{verbose}{Print progress messages}

\item{progress}{Show progress bar}
}
\value{
A fitted linear regression model for fMRI data analysis.

An fmri_lm object containing the fitted model and results
}
\description{
This function fits a linear regression model for fMRI data analysis using the specified model formula,
block structure, and dataset. The model can be fit using either a runwise or chunkwise data splitting strategy,
and robust fitting can be enabled if desired. When \code{cor_struct} is set to
one of the AR options (\code{"ar1"}, \code{"ar2"}, \code{"arp"}), the function
performs fast AR prewhitening to account for temporal autocorrelation in the
residuals.

This function fits a linear model to fMRI data using various strategies and options.
It supports both standard and robust regression, with optional AR error modeling.
}
\details{
\code{robust_options} may contain:
\itemize{
\item \code{type}: Character or logical. Type of robust fitting (\code{FALSE}, \code{"huber"}, \code{"bisquare"})
\item \code{k_huber}: Numeric. Tuning constant for Huber's psi (default: 1.345)
\item \code{c_tukey}: Numeric. Tuning constant for Tukey's bisquare psi (default: 4.685)
\item \code{max_iter}: Integer. Maximum IRLS iterations (default: 2)
\item \code{scale_scope}: Character. Scope for scale estimation (\code{"run"} or \code{"global"})
\item \code{reestimate_phi}: Logical. Whether to re-estimate AR parameters after robust fitting
}

\code{ar_options} may contain:
\itemize{
\item \code{struct}: Character. Correlation structure (\code{"iid"}, \code{"ar1"}, \code{"ar2"}, \code{"arp"})
\item \code{p}: Integer. AR order when \code{struct = "arp"}
\item \code{iter_gls}: Integer. Number of GLS iterations (default: 1)
\item \code{global}: Logical. Use global AR coefficients (default: FALSE)
\item \code{voxelwise}: Logical. Estimate AR parameters voxel-wise (default: FALSE)
\item \code{exact_first}: Logical. Apply exact AR(1) scaling to first sample (default: FALSE)
}
}
\examples{

facedes <- subset(read.table(system.file("extdata", "face_design.txt", package = "fmrireg"), 
header=TRUE), face_gen != "n/a")
facedes$face_gen <- droplevels(factor(facedes$face_gen))
sframe <- sampling_frame(rep(430/2,6), TR=2)
ev <- event_model(onset ~ hrf(face_gen, basis="gaussian"), data=facedes, 
block= ~ run, sampling_frame=sframe)
globonsets <- global_onsets(sframe, facedes$onset, blockids(ev))
reg1_signal <- regressor(globonsets[facedes$face_gen == "male"], hrf=HRF_GAUSSIAN)
reg2_signal <- regressor(globonsets[facedes$face_gen == "female"], hrf=HRF_GAUSSIAN)
time <- samples(sframe, global=TRUE)
y1 <- evaluate(reg1_signal, time)*1.5
y2 <- evaluate(reg2_signal, time)*3.0
y <- y1+y2
ys1 <- y + rnorm(length(y), sd=.02)
ys2 <- y + rnorm(length(y), sd=.02)

h <<- gen_hrf(hrf_bspline, N=7, span=25)
dset <- matrix_dataset(cbind(ys1,ys2), TR=2, run_length=sframe$blocklens, event_table=facedes)
flm <- fmri_lm(onset ~ hrf(face_gen, basis=gen_hrf(hrf_bspline, N=7, span=25)), block = ~ run, 
strategy="chunkwise", nchunks=1, dataset=dset)

}
\seealso{
\code{\link{fmri_dataset}}, \code{\link{fmri_lm_fit}}, \code{\link{fmri_lm_control}}
}
