# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' AR(p) whitening of data and design matrices
#'
#' Applies a causal AR filter defined by `phi_coeffs` to both `Y` and `X`
#' matrices in place. The filter equation is:
#' 
#' v_t = y_t - sum(phi_k * y_{t-k}, k=1 to p)
#'
#' @param Y Numeric matrix of data (time x voxels)
#' @param X Numeric matrix of design (time x predictors)  
#' @param phi_coeffs Numeric vector of AR coefficients (length p)
#' @param exact_first_ar1 Logical, apply exact variance-normalizing scaling 
#'   of first sample for AR(1). For p > 1, no scaling is applied.
#' @param parallel Logical, enable OpenMP parallelization across columns
#'
#' @details 
#' The function assumes valid (stationary) AR coefficients are provided.
#' No checks for stationarity are performed. 
#' 
#' For exact_first_ar1 = TRUE and p = 1, the first residual is multiplied 
#' by sqrt(1 - phi^2) for proper variance normalization. This scaling is 
#' only applied for AR(1) models.
#'
#' @return List with components 'Y' and 'X' containing the whitened matrices
#' @keywords internal
ar_whiten_inplace <- function(Y, X, phi_coeffs, exact_first_ar1 = FALSE, parallel = TRUE) {
    .Call('_fmrireg_ar_whiten_inplace', PACKAGE = 'fmrireg', Y, X, phi_coeffs, exact_first_ar1, parallel)
}

#' AR(p) whitening with void return (no-copy version)
#'
#' More efficient version that modifies matrices in place without returning
#' copies. Use when you don't need the return values.
#'
#' @param Y Numeric matrix of data (time x voxels) - modified in place
#' @param X Numeric matrix of design (time x predictors) - modified in place
#' @param phi_coeffs Numeric vector of AR coefficients (length p)
#' @param exact_first_ar1 Logical, apply exact scaling of first sample for AR(1)
#' @param parallel Logical, enable OpenMP parallelization across columns
#'
#' @keywords internal
ar_whiten_void <- function(Y, X, phi_coeffs, exact_first_ar1 = FALSE, parallel = TRUE) {
    invisible(.Call('_fmrireg_ar_whiten_void', PACKAGE = 'fmrireg', Y, X, phi_coeffs, exact_first_ar1, parallel))
}

instantaneous_correlation_rcpp <- function(x, y, eta = NA_real_, tau_half = NA_real_, offset = 0L, warmup = -1L, fill = "zero") {
    .Call('_fmrireg_instantaneous_correlation_rcpp', PACKAGE = 'fmrireg', x, y, eta, tau_half, offset, warmup, fill)
}

meta_fit_cpp <- function(Y, V, X, method, robust, huber_c = 1.345, robust_iter = 2L, n_threads = 0L) {
    .Call('_fmrireg_meta_fit_cpp', PACKAGE = 'fmrireg', Y, V, X, method, robust, huber_c, robust_iter, n_threads)
}

#' Meta-regression with ONE voxelwise covariate
#' 
#' @param Y S x P matrix of effect sizes
#' @param V S x P matrix of variances
#' @param X S x K design matrix
#' @param C S x P matrix of voxelwise covariates
#' @param method Meta-analysis method
#' @param robust Robust estimation method
#' @param huber_c Huber tuning constant
#' @param robust_iter Number of IRLS iterations
#' @param n_threads Number of OpenMP threads
#' @return List with results
#' @export
meta_fit_vcov_cpp <- function(Y, V, X, C, method, robust, huber_c = 1.345, robust_iter = 2L, n_threads = 0L) {
    .Call('_fmrireg_meta_fit_vcov_cpp', PACKAGE = 'fmrireg', Y, V, X, C, method, robust, huber_c, robust_iter, n_threads)
}

#' OLS t-test / ANCOVA across features
#' 
#' @param Y S x P matrix (subjects x features)
#' @param X S x K design matrix with intercept if desired
#' @return List with beta (K x P), se (K x P), t (K x P), df (scalar), ok (P)
#' @export
ols_t_cpp <- function(Y, X) {
    .Call('_fmrireg_ols_t_cpp', PACKAGE = 'fmrireg', Y, X)
}

#' Welch two-sample t-test across features
#' 
#' @param Y S x P matrix
#' @param g_in Length S vector of group indicators (1/2 or 0/1)
#' @return List with muA, muB, t, df (Welch), nA, nB
#' @export
welch_t_cpp <- function(Y, g_in) {
    .Call('_fmrireg_welch_t_cpp', PACKAGE = 'fmrireg', Y, g_in)
}

#' OLS with ONE voxelwise covariate
#' 
#' @param Y S x P matrix of outcomes
#' @param X S x K design matrix
#' @param C S x P matrix of voxelwise covariates
#' @return List with beta ((K+1) x P), se, t, df
#' @export
ols_t_vcov_cpp <- function(Y, X, C) {
    .Call('_fmrireg_ols_t_vcov_cpp', PACKAGE = 'fmrireg', Y, X, C)
}

group_pi0_counts_cpp <- function(p, group, tau) {
    .Call('_fmrireg_group_pi0_counts_cpp', PACKAGE = 'fmrireg', p, group, tau)
}

pi0_smooth_cpp <- function(pi0_raw, neighbors, lambda, iters) {
    .Call('_fmrireg_pi0_smooth_cpp', PACKAGE = 'fmrireg', pi0_raw, neighbors, lambda, iters)
}

weighted_bh_cpp <- function(p, w, alpha) {
    .Call('_fmrireg_weighted_bh_cpp', PACKAGE = 'fmrireg', p, w, alpha)
}

bh_qvalues_scaled_cpp <- function(q) {
    .Call('_fmrireg_bh_qvalues_scaled_cpp', PACKAGE = 'fmrireg', q)
}
