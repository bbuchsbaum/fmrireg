% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/all_generic.R
\name{onsets}
\alias{onsets}
\title{Return a set of data chunks}
\usage{
onsets(x)
}
\arguments{
\item{x}{The object containing event information (typically an event_term or event_model)}

\item{nchunks}{Integer; number of chunks to create (ignored if runwise=TRUE)}

\item{...}{Additional arguments passed to methods. Common arguments include:
\describe{
\item{runwise}{Logical; if TRUE, create one chunk per run}
\item{parallel}{Logical; if TRUE, prepare chunks for parallel processing}
}}
}
\value{
An iterator object that yields data chunks, where each chunk contains:
\describe{
\item{data}{Matrix of data values for this chunk}
\item{chunk_num}{Index of this chunk}
\item{voxel_ind}{Indices of voxels in this chunk}
\item{row_ind}{Indices of timepoints in this chunk}
}

A numeric vector of onset times in seconds, where:
\itemize{
\item Each value represents the start time of an event
\item Times are relative to the start of each run
\item Order matches the original event sequence
}
}
\description{
Split a dataset into manageable chunks for processing. This is particularly useful
for parallel processing of large fMRI datasets. Chunks can be created either by run
(runwise=TRUE) or by dividing the data into a specified number of pieces. Each chunk
contains a subset of the data and metadata about its position in the full dataset.

Extract the onset times of events from a model object. Onsets represent the timing of
experimental events in an fMRI design, typically in seconds from the start of each run.
These times are used to:
\itemize{
\item Create regressors by convolving with HRF
\item Verify event timing in the design
\item Analyze temporal patterns of events
}
}
\examples{
# Create a simple matrix dataset
X <- matrix(rnorm(100 * 1000), 100, 1000)  # 100 timepoints, 1000 voxels
dset <- fmridataset::matrix_dataset(
  X, 
  TR = 2,
  run_length = c(50, 50)  # Two runs of 50 timepoints each
)

# Create chunks by run
run_chunks <- fmridataset::data_chunks(dset, runwise = TRUE)

# Process each run chunk
foreach::foreach(chunk = run_chunks) \%do\% {
  # chunk$data contains the data for one run
  # chunk$row_ind shows which timepoints are included
  mean_signal <- colMeans(chunk$data)
}

# Create arbitrary number of chunks
vox_chunks <- fmridataset::data_chunks(dset, nchunks = 4)

# Process chunks in parallel
foreach::foreach(chunk = vox_chunks) \%dopar\% {
  # chunk$data contains subset of voxels
  # chunk$voxel_ind shows which voxels are included
  apply(chunk$data, 2, sd)
}
# Create event data with multiple conditions
event_data <- data.frame(
  condition = factor(c("face", "house", "face", "house")),
  onsets = c(1, 10, 20, 30),
  run = c(1, 1, 1, 1)
)

# Create sampling frame
sframe <- sampling_frame(blocklens = 50, TR = 2)

# Create event term
eterm <- event_term(
  list(condition = event_data$condition),
  onsets = event_data$onsets,
  blockids = event_data$run
)

# Get onsets from term
onset_times <- onsets(eterm)  # Returns: c(1, 10, 20, 30)

# Create and get onsets from event model
evmodel <- event_model(
  onsets ~ hrf(condition),
  data = event_data,
  block = ~run,
  sampling_frame = sframe
)

model_onsets <- onsets(evmodel)
}
\seealso{
\code{\link[=matrix_dataset]{matrix_dataset()}}, \code{\link[=fmri_dataset]{fmri_dataset()}}, \code{\link[foreach:foreach]{foreach::foreach()}}
Get event onsets from an object

\code{\link[=event_term]{event_term()}}, \code{\link[=event_model]{event_model()}}, \code{\link[=global_onsets]{global_onsets()}}

Other timing: 
\code{\link{durations}()},
\code{\link{nbasis}()},
\code{\link{split_by_block}()}
}
\concept{iterators}
\concept{timing}
