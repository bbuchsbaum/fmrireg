% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/all_generic.R
\name{Fcontrasts}
\alias{Fcontrasts}
\title{Return a set of data chunks}
\usage{
Fcontrasts(x, ...)
}
\arguments{
\item{x}{The model term to generate contrasts for (typically an event_term or event_model)}

\item{...}{Additional arguments passed to methods. Common arguments include:
\describe{
\item{basis}{Character; type of basis functions used}
\item{nbasis}{Integer; number of basis functions}
\item{exclude}{Character vector of conditions to exclude}
}}

\item{nchunks}{Integer; number of chunks to create (ignored if runwise=TRUE)}

\item{blockids}{Numeric vector specifying which blocks/runs to include (optional)}

\item{global}{Logical; if TRUE, return cumulative times across runs (default: FALSE)}
}
\value{
An iterator object that yields data chunks, where each chunk contains:
\describe{
\item{data}{Matrix of data values for this chunk}
\item{chunk_num}{Index of this chunk}
\item{voxel_ind}{Indices of voxels in this chunk}
\item{row_ind}{Indices of timepoints in this chunk}
}

A numeric vector of onset times in seconds, where:
\itemize{
\item Each value represents the start time of an event
\item Times are relative to the start of each run
\item Order matches the original event sequence
}

A numeric vector of durations in seconds, where:
\itemize{
\item Each value represents how long an event lasts
\item Zero values indicate instantaneous events
\item Order matches the corresponding event sequence
}

A numeric vector of sampling times in seconds, where:
\itemize{
\item Each value represents a scan acquisition time
\item Times account for TR (repetition time) spacing
\item If global=FALSE, times reset at the start of each run
\item If global=TRUE, times accumulate across runs
}

A list where each element contains data from one block:
\itemize{
\item List length equals number of blocks
\item Each element contains values from one block
\item Order matches the original block sequence
}

A numeric vector where:
\itemize{
\item Each element is the block/run ID for that scan
\item IDs are sequential integers starting from 1
\item Length matches the total number of scans
}

A numeric vector where:
\itemize{
\item Each element is the number of scans in a block or run
\item Length equals the number of blocks/runs
\item Values are positive integers
}

A list of contrast specifications where each contains:
\describe{
\item{weights}{Matrix of contrast weights}
\item{term}{The model term being tested}
\item{name}{Descriptive name for the contrast}
\item{df}{Degrees of freedom for the contrast}
}
}
\description{
Split a dataset into manageable chunks for processing. This is particularly useful
for parallel processing of large fMRI datasets. Chunks can be created either by run
(runwise=TRUE) or by dividing the data into a specified number of pieces. Each chunk
contains a subset of the data and metadata about its position in the full dataset.

Extract the onset times of events from a model object. Onsets represent the timing of
experimental events in an fMRI design, typically in seconds from the start of each run.
These times are used to:
\itemize{
\item Create regressors by convolving with HRF
\item Verify event timing in the design
\item Analyze temporal patterns of events
}

Extract the duration of events from a model object. Durations represent how long each
event lasts in an fMRI design, typically in seconds. These are important for:
\itemize{
\item Modeling block designs where stimuli have non-zero duration
\item Creating accurate HRF convolutions for extended events
\item Distinguishing between brief and sustained neural activity
}

Get the sampling times for a regressor or sampling frame. These times represent when
fMRI data was acquired and can be either relative (within each run) or global
(cumulative across runs). Sampling times are used to:
\itemize{
\item Evaluate regressors at scan acquisition times
\item Align model predictions with data collection
\item Convert between TR-based and time-based representations
}

Split a vector or matrix of values into separate pieces based on block/run IDs.
This function is useful for:
\itemize{
\item Separating data into individual runs
\item Processing blocks independently
\item Analyzing run-specific patterns
}

Get the block or run number associated with each scan/timepoint in the dataset.
Block indices are used to:
\itemize{
\item Track which scans belong to which runs
\item Split data by experimental blocks
\item Align events with their corresponding runs
\item Apply run-specific processing
}

Get the number of scans or timepoints in each block/run of the dataset. Block lengths
are used to:
\itemize{
\item Define the temporal structure of the experiment by specifying scan counts and timing per run
\item Allocate memory for data matrices by pre-allocating arrays based on scan counts
\item Validate data dimensions across runs by checking against expected lengths
\item Calculate global timing information by computing cumulative timing across runs
}

Create F-contrasts to test for overall effects of model terms. F-contrasts are used to:
\describe{
\item{categorical}{Test for any effect of a categorical predictor}
\item{basis}{Compare multiple basis functions simultaneously}
\item{nonlinear}{Test for nonlinear effects of continuous predictors}
\item{overall}{Evaluate overall significance of model terms}
}
}
\examples{
# Create a simple matrix dataset
X <- matrix(rnorm(100 * 1000), 100, 1000)  # 100 timepoints, 1000 voxels
dset <- fmridataset::matrix_dataset(
  X, 
  TR = 2,
  run_length = c(50, 50)  # Two runs of 50 timepoints each
)

# Create chunks by run
run_chunks <- fmridataset::data_chunks(dset, runwise = TRUE)

# Process each run chunk
foreach::foreach(chunk = run_chunks) \%do\% {
  # chunk$data contains the data for one run
  # chunk$row_ind shows which timepoints are included
  mean_signal <- colMeans(chunk$data)
}

# Create arbitrary number of chunks
vox_chunks <- fmridataset::data_chunks(dset, nchunks = 4)

# Process chunks in parallel
foreach::foreach(chunk = vox_chunks) \%dopar\% {
  # chunk$data contains subset of voxels
  # chunk$voxel_ind shows which voxels are included
  apply(chunk$data, 2, sd)
}
# Create event data with multiple conditions
event_data <- data.frame(
  condition = factor(c("face", "house", "face", "house")),
  onsets = c(1, 10, 20, 30),
  run = c(1, 1, 1, 1)
)

# Create sampling frame
sframe <- sampling_frame(blocklens = 50, TR = 2)

# Create event term
eterm <- event_term(
  list(condition = event_data$condition),
  onsets = event_data$onsets,
  blockids = event_data$run
)

# Get onsets from term
onset_times <- onsets(eterm)  # Returns: c(1, 10, 20, 30)

# Create and get onsets from event model
evmodel <- event_model(
  onsets ~ hrf(condition),
  data = event_data,
  block = ~run,
  sampling_frame = sframe
)

model_onsets <- onsets(evmodel)
# Create event data with varying durations
event_data <- data.frame(
  condition = factor(c("block", "event", "block", "event")),
  onsets = c(1, 10, 20, 30),
  durations = c(8, 0, 8, 0),  # 8s blocks and instantaneous events
  run = c(1, 1, 1, 1)
)

# Create event term
eterm <- event_term(
  list(condition = event_data$condition),
  onsets = event_data$onsets,
  durations = event_data$durations,
  blockids = event_data$run
)

# Get durations from term
dur <- durations(eterm)  # Returns: c(8, 0, 8, 0)
# Create a sampling frame with multiple runs
sframe <- sampling_frame(
  blocklens = c(100, 100, 100),  # 100 scans per run
  TR = 2,                        # 2 seconds per scan
  start_time = 0                 # Start at time 0
)

# Get relative sampling times (reset each run)
rel_times <- samples(sframe)
# First few times: 0, 2, 4, 6, ... (resets each run)

# Get global sampling times (cumulative)
glob_times <- samples(sframe, global = TRUE)
# Shows: 0, 2, 4, ..., 198, 200, 202, ..., 598

# Get times for specific runs
run2_times <- samples(sframe, blockids = 2)
# Times for second run only

# Create regressor and get its sampling times
event_data <- data.frame(
  onsets = c(1, 10, 20),
  run = c(1, 1, 1)
)
reg <- regressor(
  onsets = event_data$onsets,
  sampling_frame = sframe
)
reg_times <- samples(reg)
# Create a sampling frame with multiple runs
sframe <- sampling_frame(
  blocklens = c(50, 50, 50),  # 3 runs of 50 scans each
  TR = 2
)

# Create some example data
data_values <- rnorm(150)  # 150 values (50 per run)

# Split data by run
run_data <- split_by_block(sframe, data_values)
# Returns list with 3 elements, each containing 50 values

# Create matrix dataset
X <- matrix(rnorm(150 * 10), 150, 10)  # 150 timepoints, 10 voxels
dset <- fmridataset::matrix_dataset(
  X,
  TR = 2,
  run_length = c(50, 50, 50)
)

# Split matrix data by run
run_matrices <- split_by_block(dset)
# Returns list with 3 matrices, each 50 x 10
# Create a sampling frame with multiple runs
sframe <- sampling_frame(
  blocklens = c(50, 75, 50),  # Different length runs
  TR = 2
)

# Get block IDs for all scans
block_ids <- blockids(sframe)
# Returns: c(1,1,...,1, 2,2,...,2, 3,3,...,3)
# 50 ones, 75 twos, 50 threes

# Create a matrix dataset
X <- matrix(rnorm(175 * 10), 175, 10)  # 175 timepoints (50+75+50), 10 voxels
dset <- fmridataset::matrix_dataset(
  X,
  TR = 2,
  run_length = c(50, 75, 50)
)

# Note: blockids method for matrix_dataset is in the fmridataset package
# To get block IDs from a dataset, ensure fmridataset is loaded
# Create a sampling frame with varying run lengths
sframe <- sampling_frame(
  blocklens = c(100, 150, 100),  # Different length runs
  TR = 2
)

# Get number of scans per run
run_lengths <- blocklens(sframe)  # Returns: c(100, 150, 100)

# Use block lengths to create a dataset
total_scans <- sum(run_lengths)  # 350 total timepoints
X <- matrix(rnorm(total_scans * 10), total_scans, 10)  # 10 voxels
dset <- fmridataset::matrix_dataset(
  X,
  TR = 2,
  run_length = run_lengths
)

# Verify block lengths in dataset
dset_lengths <- blocklens(dset)

# Use lengths to create time vectors for each run
time_vectors <- lapply(run_lengths, function(len) seq(0, by = 2, length.out = len))
# Create event data with multiple conditions
event_data <- data.frame(
  condition = factor(c("A", "B", "C", "A", "B", "C")),
  rt = c(0.8, 1.2, 0.9, 1.1, 0.7, 1.3),
  onsets = c(1, 10, 20, 30, 40, 50),
  run = c(1, 1, 1, 1, 1, 1)
)

# Create sampling frame
sframe <- sampling_frame(blocklens = 60, TR = 2)

# Create event model with multiple terms
evmodel <- event_model(
  onsets ~ hrf(condition) + hrf(rt),
  data = event_data,
  block = ~run,
  sampling_frame = sframe
)

# Get F-contrast for main effect of condition
cond_contrast <- Fcontrasts(evmodel)

# Create model with multiple basis functions
evmodel2 <- event_model(
  onsets ~ hrf(condition, basis = "fourier", nbasis = 3),
  data = event_data,
  block = ~run,
  sampling_frame = sframe
)

# Get F-contrasts testing all basis functions
basis_contrasts <- Fcontrasts(evmodel2)
}
\seealso{
\code{\link[=matrix_dataset]{matrix_dataset()}}, \code{\link[=fmri_dataset]{fmri_dataset()}}, \code{\link[foreach:foreach]{foreach::foreach()}}
Get event onsets from an object

\code{\link[=event_term]{event_term()}}, \code{\link[=event_model]{event_model()}}, \code{\link[=global_onsets]{global_onsets()}}
Get event durations from an object

\code{\link[=onsets]{onsets()}}, \code{\link[=event_term]{event_term()}}
Extract sampling times

\code{\link[=sampling_frame]{sampling_frame()}}, \code{\link[=regressor]{regressor()}}, \code{\link[=global_onsets]{global_onsets()}}
Split variables by block ID

\code{\link[=sampling_frame]{sampling_frame()}}, \code{\link[=blockids]{blockids()}}, \code{\link[=blocklens]{blocklens()}}
Get block/run indices

\code{\link[=blocklens]{blocklens()}}, \code{\link[=split_by_block]{split_by_block()}}, \code{\link[=sampling_frame]{sampling_frame()}}
Get block/run lengths

\code{\link[=blockids]{blockids()}}, \code{\link[=split_by_block]{split_by_block()}}, \code{\link[=sampling_frame]{sampling_frame()}}
Generate F-contrasts for a model term

\code{\link[=event_model]{event_model()}}, \code{\link[=contrast_weights]{contrast_weights()}}

Other timing: 
\code{\link{nbasis}()}

Other timing: 
\code{\link{nbasis}()}

Other timing: 
\code{\link{nbasis}()}
}
\concept{block_operations}
\concept{contrasts}
\concept{iterators}
\concept{timing}
