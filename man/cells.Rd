% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/all_generic.R, R/baseline_model.R,
%   R/event-classes.R, R/event_vector.R
\name{cells}
\alias{cells}
\alias{cells.baseline_model}
\alias{cells.event}
\alias{cells.event_term}
\alias{cells.covariate_convolved_term}
\title{The experimental cells of a design}
\usage{
cells(x, ...)

\method{cells}{baseline_model}(x, ...)

\method{cells}{event}(x, drop.empty = TRUE, ...)

\method{cells}{event_term}(x, drop.empty = TRUE, ...)

\method{cells}{covariate_convolved_term}(x, ...)
}
\arguments{
\item{x}{An event_term object.}

\item{...}{Additional arguments (unused).}

\item{drop.empty}{Logical; if TRUE (default), remove cells with zero observed events.}
}
\value{
A tibble containing the experimental cells with attributes:
\describe{
\item{count}{Number of events in each cell}
\item{rownames}{Cell names when cells have multiple factors}
}

A tibble with columns: term, level, basis, and index.

A one-column tibble (\code{.level} or \code{.name}) with a \code{count} attribute.

A tibble where rows represent unique cells and columns represent the event
variables in the term. Has a \code{count} attribute.
}
\description{
Return the experimental cells that are in a model term as a table. Experimental cells
represent unique combinations of factor levels in the design. For example, if a design
has factors A (levels: a1, a2) and B (levels: b1, b2), the cells would be: a1:b1,
a1:b2, a2:b1, a2:b2.

Combines the cells from all baseline terms into a tibble with an index.

For categorical events, returns observed factor levels and counts.
For continuous events, returns the variable name as a single cell with the total event count.

Calculates all unique combinations (cells) of levels across all event variables
in the term. It uses \code{levels.event} for each event and \code{expand.grid}.
It then calculates the number of observed events corresponding to each cell
by comparing against the output of \code{elements(x, values=FALSE)} and attaches this
as a \code{count} attribute to the resulting tibble.
Relies on \code{levels.event}, \code{is_categorical.event}, and \code{elements.event}.
}
\details{
Note: For designs with many interacting factors each having many levels,
the internal calculation based on \code{expand.grid} might become slow.
}
\examples{
# Create a simple factorial design
evlist <- list(
  fac1 = factor(c("A", "B", "A", "B")),
  fac2 = factor(c("1", "1", "2", "2"))
)

# Create an event term
eterm <- event_term(
  evlist,
  onsets = 1:4,
  blockids = rep(1, 4)
)

# Get the experimental cells
cells(eterm)  # Returns cells: A:1, A:2, B:1, B:2

# Create an event model
event_data <- data.frame(
  fac = c("a", "B", "A", "B"),
  onsets = c(1, 10, 20, 80),
  run = c(1, 1, 1, 1)
)
sframe <- sampling_frame(blocklens = 50, TR = 2)
evmodel <- event_model(
  onsets ~ hrf(fac),
  data = event_data,
  block = ~run,
  sampling_frame = sframe
)

# Get cells from the model
cells(evmodel)
sframe <- sampling_frame(blocklens = 10, TR = 1)
bmod <- baseline_model(sframe = sframe)
cells(bmod)
x1 <- factor(rep(letters[1:3], 4))
x2 <- factor(rep(1:2, each = 6))
onsets <- seq(1, 100, length.out = 12)
blockids <- rep(1, 12)
eterm <- event_term(list(Condition = x1, Group = x2), onsets=onsets, blockids=blockids)
cells(eterm)
cells(eterm, drop.empty=FALSE)
}
\seealso{
\code{\link[=event_term]{event_term()}}, \code{\link[=event_model]{event_model()}}
}
\concept{cells}
