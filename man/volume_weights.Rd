% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/volume_quality.R
\name{volume_weights}
\alias{volume_weights}
\title{Compute Volume Quality Weights from Data}
\usage{
volume_weights(
  Y,
  method = "inverse_squared",
  threshold = 1.5,
  return_dvars = FALSE
)
}
\arguments{
\item{Y}{Numeric matrix of fMRI data (time x voxels).}

\item{method}{Weighting method passed to \code{dvars_to_weights}.}

\item{threshold}{Threshold passed to \code{dvars_to_weights}.}

\item{return_dvars}{Logical. If TRUE, return both weights and DVARS.}
}
\value{
If return_dvars is FALSE, a numeric vector of weights.
If TRUE, a list with components "weights" and "dvars".
}
\description{
Convenience function that computes DVARS and converts to weights in one step.
This is the main user-facing function for volume quality weighting.
}
\examples{
set.seed(123)
Y <- matrix(rnorm(100 * 50), nrow = 100, ncol = 50)
Y[50, ] <- Y[50, ] + 5  # Add artifact

# One-step computation of weights
result <- volume_weights(Y, return_dvars = TRUE)
cat("DVARS at artifact:", round(result$dvars[50], 2), "\n")
cat("Weight at artifact:", round(result$weights[50], 3), "\n")

# With Tukey method for more aggressive downweighting
w_tukey <- volume_weights(Y, method = "tukey")
}
