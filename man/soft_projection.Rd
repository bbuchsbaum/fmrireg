% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/soft_subspace_projection.R
\name{soft_projection}
\alias{soft_projection}
\title{Create Soft Projection Operator}
\usage{
soft_projection(N, lambda = "auto", Y = NULL)
}
\arguments{
\item{N}{Nuisance matrix (time x nuisance_voxels). Typically extracted
from white matter and CSF voxels. Can have many columns (thousands);
computational cost depends on min(nrow, ncol) due to SVD.}

\item{lambda}{Ridge penalty controlling shrinkage strength:
\describe{
\item{"auto"}{(Default) Uses median of squared singular values.
Fast, stable, requires no tuning.
Recommended for most use cases.}
\item{"gcv"}{Generalized cross-validation. Optimizes prediction of Y
from N with ridge penalty. Requires Y parameter. More principled but
slower.}
\item{numeric}{User-specified value. Larger = less aggressive removal.}
}}

\item{Y}{Optional data matrix for GCV-based lambda selection. Required if
\code{lambda = "gcv"}, ignored otherwise.}
}
\value{
A list with class \code{"soft_projection"} containing:
\item{P_lambda}{Function that applies the projection to a matrix}
\item{lambda}{The selected/specified lambda value}
\item{method}{Method used: "singular_value_heuristic", "gcv", or "user_specified"}
\item{effective_df}{Effective degrees of freedom removed (sum of shrinkage factors)}
\item{n_nuisance}{Number of nuisance columns in N}
\item{n_timepoints}{Number of timepoints}
}
\description{
Computes the soft (ridge-regularized) projection matrix that removes
variance explainable by the nuisance subspace while avoiding overfitting.
}
\examples{
# Create nuisance matrix (e.g., from WM/CSF voxels)
set.seed(123)
N <- matrix(rnorm(100 * 20), nrow = 100, ncol = 20)
proj <- soft_projection(N, lambda = "auto")

# Apply to data and design
Y <- matrix(rnorm(100 * 50), nrow = 100, ncol = 50)
Y_clean <- proj$P_lambda(Y)

# Full workflow: project both data and design
X <- cbind(1, rnorm(100), rnorm(100))  # intercept + 2 predictors
cleaned <- apply_soft_projection(proj, Y, X)
# Now fit GLM with cleaned$Y and cleaned$X

# Using GCV for lambda selection (data-driven)
proj_gcv <- soft_projection(N, lambda = "gcv", Y = Y)
print(proj_gcv)  # Shows selected lambda and effective df
}
