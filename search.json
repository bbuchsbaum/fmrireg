[{"path":"https://bbuchsbaum.github.io/fmrireg/CLAUDE.html","id":null,"dir":"","previous_headings":"","what":"CLAUDE.md","title":"CLAUDE.md","text":"file provides guidance Claude Code (claude.ai/code) working code repository.","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmrireg/CLAUDE.html","id":"package-building-and-checking","dir":"","previous_headings":"Build and Development Commands","what":"Package Building and Checking","title":"CLAUDE.md","text":"devtools::document() - Generate/update documentation roxygen2 comments devtools::check(cran = TRUE) - Run comprehensive CRAN checks (gold standard) devtools::spell_check() - Check spelling documentation DESCRIPTION urlchecker::url_check() - Validate URLs documentation devtools::check_win_devel() - Check Windows development version rhub::check_for_cran() - Run multi-platform CRAN checks","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/CLAUDE.html","id":"testing","dir":"","previous_headings":"Build and Development Commands","what":"Testing","title":"CLAUDE.md","text":"devtools::test() - Run tests testthat::test_local() - Run tests locally testthat::test_file(\"tests/testthat/test_specific.R\") - Run single test file Tests located tests/testthat/","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/CLAUDE.html","id":"documentation","dir":"","previous_headings":"Build and Development Commands","what":"Documentation","title":"CLAUDE.md","text":"pkgdown::build_site() - Build package website Documentation follows CRAN guidelines strictly (see CRAN_guidance.md)","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/CLAUDE.html","id":"high-level-architecture","dir":"","previous_headings":"","what":"High-Level Architecture","title":"CLAUDE.md","text":"fmrireg R package fMRI time series regression analysis layered architecture:","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/CLAUDE.html","id":"core-abstractions","dir":"","previous_headings":"High-Level Architecture","what":"Core Abstractions","title":"CLAUDE.md","text":"event_factor: Categorical experimental events event_variable: Continuous experimental variables event_matrix: Matrix-based events Events convolved HRFs create regressors Base HRF class various implementations (gamma, gaussian, spline, etc.) HRFs can modified via decorators (lag, block, normalize) Supports custom basis sets parametric variations baseline_model: Nuisance regressors (drift, motion, etc.) event_model: Experimental design (events + HRFs) fmri_model: Complete model (baseline + events) fmri_dataset: Base class fMRI data matrix_dataset: -memory matrix data fmri_mem_dataset: Memory-mapped fMRI data latent_dataset: Reduced dimensionality data fmri_lm: Standard GLM fitting fmri_rlm: Robust GLM fitting Supports different strategies: runwise, chunkwise, trial-wise C++ implementations performance (mixed_solve, AR whitening) Flexible contrast specification via formulas Support F-contrasts, pairwise, polynomial contrasts","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/CLAUDE.html","id":"key-design-patterns","dir":"","previous_headings":"High-Level Architecture","what":"Key Design Patterns","title":"CLAUDE.md","text":"S3 Object System: generics defined R/all_generic.R Builder Pattern: Models built incrementally (events → event_model → fmri_model) Strategy Pattern: Different fitting algorithms (OLS, robust, regularized) Decorator Pattern: HRF modifications (lag_hrf, block_hrf)","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/CLAUDE.html","id":"performance-considerations","dir":"","previous_headings":"High-Level Architecture","what":"Performance Considerations","title":"CLAUDE.md","text":"C++ implementations via Rcpp computationally intensive operations Parallelization via RcppParallel (configurable: options(fmrireg.num_threads = N)) Chunked processing large datasets manage memory","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/CLAUDE.html","id":"cran-compliance","dir":"","previous_headings":"High-Level Architecture","what":"CRAN Compliance","title":"CLAUDE.md","text":"package strictly follows CRAN guidelines: - S3 generics primary documentation site - Methods use @rdname link generic documentation - examples must run quickly (< 5 seconds) - Avoid modifying user options par() without restoration - See CRAN_guidance.md detailed guidelines","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/CLAUDE.html","id":"development-principles","dir":"","previous_headings":"High-Level Architecture","what":"Development Principles","title":"CLAUDE.md","text":"data-raw/principles.md: - Single source truth data representations - Encapsulation reconstruction - Clear separation concerns - Functional composition preferred - Object-oriented design S3 - One way one thing - Fail fast locally clear error messages","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/CLAUDE.html","id":"critical-test-issues-resolved-2025-05-28","dir":"","previous_headings":"","what":"CRITICAL TEST ISSUES RESOLVED (2025-05-28)","title":"CLAUDE.md","text":"critical functionality tests now passing following fixes: Updated solve_integrated_glm handle config structures (config$ar$struct config$ar_options$cor_struct) Added proper config extraction pipeline functions Files modified: fmri_lm_integrated_solver.R Corrected formula use sum weights approach: df = sum(weights) - p File modified: fmri_lm_effective_df.R Added XtXinv pipeline results contrast computation Added dfres core solver results Files modified: fmri_lm_integrated_solver.R, fmri_lm_solver.R 6 critical tests now pass: - ✓ AR whitening integration - ✓ Robust fitting - ✓ Contrast computation - ✓ Effective df calculations - ✓ Bootstrap functionality - ✓ Sandwich variance estimator refactored code now ready integration existing codebase.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/Overview.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Overview of the fmrireg Package","text":"fmrireg package provides tools analyzing fMRI regression models R, inspired standard R modeling tools like lm() glm(). integrates hemodynamic response functions design matrix construction comprehensive fMRI analysis. fMRI analysis involves complexities like large datasets, spatio-temporal correlations, physiological noise, core standard univariate analysis multiple regression applied voxelwise. fmrireg package simplifies specification estimation regression models. vignette provides high-level overview key steps components involved using fmrireg.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/Overview.html","id":"key-components-and-workflow","dir":"Articles","previous_headings":"","what":"Key Components and Workflow","title":"Overview of the fmrireg Package","text":"typical fMRI analysis workflow fmrireg involves main stages: Data Representation: Defining fMRI data experimental design organized. Defining Hemodynamic Response Functions (HRFs). Creating event-related regressors (event_model). Modeling baseline components like drift nuisance factors (baseline_model). Defining contrasts interest (contrast). Model Estimation: Fitting specified model data (e.g., using fmri_lm). Advanced Topics: Exploring single-trial estimation, simulation, translation packages.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/Overview.html","id":"data-representation","dir":"Articles","previous_headings":"Key Components and Workflow","what":"1. Data Representation","title":"Overview of the fmrireg Package","text":"modeling, need represent fMRI data structure. fmrireg uses objects like: fmri_dataset / fmri_mem_dataset: Encapsulates 4D fMRI data (potentially file-backed -memory), mask information, TR, run structure, experimental design table. sampling_frame: Defines temporal structure – number scans per run (blocklens) repetition time (TR).","code":"# Example: 5 runs, 200 scans/run, TR=2s sframe <- sampling_frame(blocklens = rep(200, 5), TR = 2) sframe #> Sampling Frame #> ============== #>  #> Structure: #>   5 blocks #>   Total scans: 1000 #>  #> Timing: #>   TR: 2 s #>   Precision: 0.1 s #>  #> Duration: #>   Total time: 2000.0 s"},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/Overview.html","id":"a-hemodynamic-response-function-hrf","dir":"Articles","previous_headings":"Key Components and Workflow > 2. Model Building","what":"a) Hemodynamic Response Function (HRF)","title":"Overview of the fmrireg Package","text":"HRF models BOLD signal response brief neural event. fmrireg provides various pre-defined HRFs (e.g., HRF_SPMG1, HRF_GAUSSIAN) functions create modify (gen_hrf, hrf_blocked, hrf_lagged).  Related Topic: Hemodynamic Response Functions","code":"# Plot the SPM canonical HRF time <- seq(0, 24, by = 0.2) plot(time, HRF_SPMG1(time), type = 'l', xlab = \"Time (s)\", ylab = \"BOLD Response\",      main = \"SPM Canonical HRF (HRF_SPMG1)\")"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/Overview.html","id":"b-event-model-event_model","dir":"Articles","previous_headings":"Key Components and Workflow > 2. Model Building","what":"b) Event Model (event_model)","title":"Overview of the fmrireg Package","text":"defines task-related part GLM. specify experimental events (onsets, conditions, durations) map regressors using formula syntax. hrf() afni_hrf() functions within formula link event variables specific HRF shapes. Related Topic: Event Models","code":"# Example: Model effect of 'stim_type', using SPMG1 HRF # (Assuming 'my_design_table' and 'my_sampling_frame' exist) event_mod <- event_model(onset ~ hrf(stim_type),                           data = my_design_table,                           block = ~ run_id,                           sampling_frame = my_sampling_frame)"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/Overview.html","id":"c-baseline-model-baseline_model","dir":"Articles","previous_headings":"Key Components and Workflow > 2. Model Building","what":"c) Baseline Model (baseline_model)","title":"Overview of the fmrireg Package","text":"models non-task-related components like scanner drift, run intercepts, nuisance factors (e.g., motion parameters). Related Topic: Baseline Models","code":"# Example: Cubic B-spline drift model + run intercepts # (Requires 'sframe' defined earlier) base_mod <- baseline_model(basis = \"bs\", degree = 3, sframe = sframe) print(base_mod) #> ================================================ #>            Baseline Model                        #> ================================================ #>   Drift Components                            #>     * Name: baseline_bs_3                 #>     * Basis type: bs                      #>     * Degree: 3                           #>     * Drift columns: 15                   #>  #>   Additional Components                     #>     * Constant columns: 5                 #>     * Nuisance columns: 0                 #>  #>   Model Summary                             #>     * Total columns: 20                   #>  #>   Design Matrix Preview                     #>      0.000  0.000  0.000  0.000 ...       #>      0.015  0.000  0.000  0.000 ...       #>      0.030  0.000  0.000  0.000 ...       #> ================================================"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/Overview.html","id":"d-contrasts-pair_contrast-unit_contrast-etc-","dir":"Articles","previous_headings":"Key Components and Workflow > 2. Model Building","what":"d) Contrasts (pair_contrast, unit_contrast, etc.)","title":"Overview of the fmrireg Package","text":"Contrasts define specific comparisons condition estimates. See Vignette: vignette(\"a_05_contrasts\", package = \"fmrireg\")","code":"# Example: Contrast comparing 'face' vs 'scene' levels of 'stim_type' face_vs_scene <- pair_contrast(~ stim_type == \"face\", ~ stim_type == \"scene\", name = \"FvS\") print(face_vs_scene) #> contrast: FvS  #>  A:  ~stim_type == \"face\"  #>  B:  ~stim_type == \"scene\""},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/Overview.html","id":"model-estimation-fmri_model-fmri_lm","dir":"Articles","previous_headings":"Key Components and Workflow","what":"3. Model Estimation (fmri_model, fmri_lm)","title":"Overview of the fmrireg Package","text":"combine event baseline models full fmri_model fit fmri_dataset using estimation functions like fmri_lm (standard GLM) estimate_betas (single-trial betas). Setting robust = TRUE invokes row-wise weighting lessen influence motion spikes frame-level artifacts. vignette(\"a_09_linear_model\", package = \"fmrireg\") Linear Models Trialwise Analysis","code":"# Combine event and baseline models full_model <- fmri_model(event_mod, base_mod)  # Fit the GLM # (Requires 'my_dataset' of class fmri_dataset) fit <- fmri_lm(full_model, dataset = my_dataset)  # Robust fit down-weighting outlier time points fit_robust <- fmri_lm(full_model, dataset = my_dataset, robust = TRUE)  # Extract contrast results (if contrasts were defined) # con_results <- coef(fit)  # Get coefficients"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/Overview.html","id":"advanced-topics","dir":"Articles","previous_headings":"Key Components and Workflow","what":"4. Advanced Topics","title":"Overview of the fmrireg Package","text":"fmrireg also supports: vignette(\"a_08_simulation\", package = \"fmrireg\") AFNI Translation: Generating scripts AFNI’s 3dDeconvolve (afni_lm). Low-level Regressors: Manually creating manipulating regressors (regressor).","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/Overview.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting Started","title":"Overview of the fmrireg Package","text":"overview provides map fmrireg package. detailed explanations examples, please refer specific vignettes linked .","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_05_contrasts.html","id":"introduction-to-contrasts","dir":"Articles","previous_headings":"","what":"Introduction to Contrasts","title":"Contrasts in fmrireg","text":"Statistical contrasts fundamental component fMRI analyses, allowing researchers test specific hypotheses differences brain activity experimental conditions. fmrireg package provides flexible powerful system defining, computing, applying contrasts linear models fitted fMRI data. vignette explores various ways specify contrasts fmrireg, simple pairwise comparisons complex interactions polynomial trends.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_05_contrasts.html","id":"example-a-2x2-factorial-design","dir":"Articles","previous_headings":"","what":"Example: A 2x2 Factorial Design","title":"Contrasts in fmrireg","text":"illustrate contrast functionalities, let’s use simple two--two factorial design. two factors: category: levels “face” “scene” attention: levels “attend” “ignore” ’ll assume unique condition repeated twice within single run. First, construct event table representing design: 2x2 Experimental Design Table Cells within ‘category:attention’ event term event_term object encapsulates structure experimental conditions used compute contrast weights.","code":"design <- expand.grid(category = c(\"face\", \"scene\"),                        attention = c(\"attend\", \"ignore\"),                        replication = c(1, 2)) design$onset <- seq(1, 100, length.out = nrow(design)) # Assign arbitrary onsets design$block <- rep(1, nrow(design))                  # Single block (run)  # Ensure factors are factors design$category <- factor(design$category) design$attention <- factor(design$attention)  kable(design, caption = \"2x2 Experimental Design Table\") # Define a sampling frame and create the event model sframe <- sampling_frame(blocklens = 120, TR = 2) emodel <- event_model(onset ~ hrf(category, attention),                        block = ~block,                        data = design,                        sampling_frame = sframe)  # Extract the event term for contrast calculation # In this simple model, there's only one event term event_term <- terms(emodel)[[1]]   kable(cells(event_term), caption = \"Cells within the 'category:attention' event term\")"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_05_contrasts.html","id":"basic-contrasts-pair_contrast","dir":"Articles","previous_headings":"","what":"Basic Contrasts: pair_contrast","title":"Contrasts in fmrireg","text":"common type contrast compares average activation one set conditions another. pair_contrast function provides convenient way define sum--zero contrasts.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_05_contrasts.html","id":"defining-pair-contrasts","dir":"Articles","previous_headings":"Basic Contrasts: pair_contrast","what":"Defining Pair Contrasts","title":"Contrasts in fmrireg","text":"pair_contrast takes two formulas, B, defining conditions compare, mandatory name. Let’s define contrasts main effects category (face vs. scene) attention (attend vs. ignore):","code":"# Main effect of category: face > scene con_face_vs_scene <- pair_contrast(~ category == \"face\",                                   ~ category == \"scene\",                                   name = \"face_vs_scene\")  # Main effect of attention: attend > ignore con_attend_vs_ignore <- pair_contrast(~ attention == \"attend\",                                      ~ attention == \"ignore\",                                      name = \"attend_vs_ignore\")"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_05_contrasts.html","id":"computing-contrast-weights","dir":"Articles","previous_headings":"Basic Contrasts: pair_contrast","what":"Computing Contrast Weights","title":"Contrasts in fmrireg","text":"Contrast specifications abstract applied specific model term structure. contrast_weights function computes numerical weights based levels within term. Notice pair_contrast automatically averages levels mentioned formulas. face_vs_scene, averages ‘attend’ ‘ignore’ within category level contrasting. resulting weights sum zero (0.25 * 2 + (-0.25) * 2 = 0).","code":"wts_face_vs_scene <- contrast_weights(con_face_vs_scene, event_term) wts_attend_vs_ignore <- contrast_weights(con_attend_vs_ignore, event_term)  cat(\"Weights for 'face_vs_scene':\\n\") ## Weights for 'face_vs_scene': kable(wts_face_vs_scene$weights, col.names = wts_face_vs_scene$name) cat(\"\\nWeights for 'attend_vs_ignore':\\n\") ##  ## Weights for 'attend_vs_ignore': kable(wts_attend_vs_ignore$weights, col.names = wts_attend_vs_ignore$name)"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_05_contrasts.html","id":"unit-contrasts-comparing-to-baseline","dir":"Articles","previous_headings":"","what":"Unit Contrasts: Comparing to Baseline","title":"Contrasts in fmrireg","text":"Sometimes, want test whether activation condition (set conditions) significantly different implicit baseline (often represented intercept model). unit_contrast used purpose. creates contrasts sum 1. weights average specified conditions compare zero (implicit baseline).","code":"con_face_vs_baseline <- unit_contrast(~ category == \"face\", name = \"face_gt_baseline\") con_attend_vs_baseline <- unit_contrast(~ attention == \"attend\", name = \"attend_gt_baseline\")  wts_face_vs_baseline <- contrast_weights(con_face_vs_baseline, event_term) wts_attend_vs_baseline <- contrast_weights(con_attend_vs_baseline, event_term)  cat(\"Weights for 'face_gt_baseline':\\n\") ## Weights for 'face_gt_baseline': kable(wts_face_vs_baseline$weights, col.names = wts_face_vs_baseline$name) cat(\"\\nWeights for 'attend_gt_baseline':\\n\") ##  ## Weights for 'attend_gt_baseline': kable(wts_attend_vs_baseline$weights, col.names = wts_attend_vs_baseline$name)"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_05_contrasts.html","id":"general-contrasts-with-contrast","dir":"Articles","previous_headings":"","what":"General Contrasts with contrast()","title":"Contrasts in fmrireg","text":"contrast() function allows complex contrasts defined single formula expression. useful interactions specific linear combinations conditions. Let’s define interaction contrast: (face:attend - face:ignore) - (scene:attend - scene:ignore). tests effect attention differs categories. Note: formula contrast(), condition names formed joining factor levels colons (e.g., face:attend). condition names contain special characters like colons, must enclosed backticks. contrast_weights function evaluates formula environment condition name corresponds column vector (1 condition, 0 otherwise).","code":"# Interaction contrast con_interaction <- contrast(   ~ (`face:attend` - `face:ignore`) - (`scene:attend` - `scene:ignore`),   name = \"category_X_attention\" )  wts_interaction <- contrast_weights(con_interaction, event_term)  cat(\"Weights for 'category_X_attention':\\n\") ## Weights for 'category_X_attention': kable(wts_interaction$weights, col.names = wts_interaction$name)"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_05_contrasts.html","id":"contrasts-for-main-effects-and-interactions","dir":"Articles","previous_headings":"","what":"Contrasts for Main Effects and Interactions","title":"Contrasts in fmrireg","text":"pair_contrast contrast flexible, fmrireg provides convenience functions standard ANOVA-like contrasts. oneway_contrast: Generates contrasts main effect single factor (sum--zero coding). interaction_contrast: Generates contrasts interaction effects two factors. often result multiple contrast columns (F-contrasts) testing overall effect. Note weights generated interaction_contrast(~ category * attention) match manually specified using contrast(). factors levels, functions generate multiple orthogonal contrast columns.","code":"# Main effect of category (will produce 1 contrast vector) con_main_category <- oneway_contrast(~ category, name = \"Main_Category\") wts_main_category <- contrast_weights(con_main_category, event_term)  # Interaction effect (will produce 1 contrast vector for a 2x2 design) con_int_cat_att <- interaction_contrast(~ category * attention, name = \"Interaction_CatAtt\") wts_int_cat_att <- contrast_weights(con_int_cat_att, event_term)  cat(\"Weights for 'Main_Category' (oneway_contrast):\\n\") ## Weights for 'Main_Category' (oneway_contrast): kable(wts_main_category$weights) cat(\"\\nWeights for 'Interaction_CatAtt' (interaction_contrast):\\n\") ##  ## Weights for 'Interaction_CatAtt' (interaction_contrast): kable(wts_int_cat_att$weights)"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_05_contrasts.html","id":"polynomial-contrasts-for-ordered-factors","dir":"Articles","previous_headings":"","what":"Polynomial Contrasts for Ordered Factors","title":"Contrasts in fmrireg","text":"factor represents ordered levels (e.g., different task difficulty levels, time points), poly_contrast can test trends (linear, quadratic, etc.). Let’s add ‘intensity’ factor design: Design Ordered ‘intensity’ Factor Now, define polynomial contrast test linear quadratic trends intensity: output two columns: poly1 linear trend poly2 quadratic trend.","code":"design_poly <- expand.grid(category = c(\"face\", \"scene\"),                             intensity = c(1, 2, 3), # Ordered factor                            replication = c(1)) design_poly$onset <- seq(1, 60, length.out = nrow(design_poly)) design_poly$block <- rep(1, nrow(design_poly))  design_poly$intensity <- factor(design_poly$intensity, ordered = TRUE)  kable(design_poly, caption = \"Design with Ordered 'intensity' Factor\") emodel_poly <- event_model(onset ~ hrf(category, intensity),                             block = ~block,                             data = design_poly,                             sampling_frame = sframe) event_term_poly <- terms(emodel_poly)[[1]] con_poly_intensity <- poly_contrast(~ intensity, degree = 2, name = \"Intensity_Trend\") wts_poly_intensity <- contrast_weights(con_poly_intensity, event_term_poly)  cat(\"Weights for 'Intensity_Trend' (poly_contrast, degree=2):\\n\") ## Weights for 'Intensity_Trend' (poly_contrast, degree=2): kable(wts_poly_intensity$weights)"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_05_contrasts.html","id":"helper-functions-for-common-comparisons","dir":"Articles","previous_headings":"","what":"Helper Functions for Common Comparisons","title":"Contrasts in fmrireg","text":"Two helpers simplify common multi-level comparisons: pair_contrast: Creates pairwise comparison two levels factor. one_against_all_contrast: Compares level average levels.","code":"# Pairwise contrast for category using pair_contrast con_pairwise_cat <- pair_contrast(~ category == \"face\",                                   ~ category == \"scene\",                                   name = \"cat_face_scene\")  # Compare each attention level vs the other con_one_all_att <- one_against_all_contrast(levels(design$attention), facname = \"attention\")  # Since con_one_all_att is already a contrast_set, we need to extract its elements # and combine them properly with the single contrast all_helper_contrasts <- list(con_pairwise_cat) all_helper_contrasts <- append(all_helper_contrasts, con_one_all_att) con_set_helpers <- do.call(contrast_set, all_helper_contrasts)  # Calculate weights (demonstrating contrast_set) wts_helpers <- contrast_weights(con_set_helpers, event_term)  # Display weights for one_against_all cat(\"Weights for 'con_attend_vs_other':\\n\") ## Weights for 'con_attend_vs_other': kable(wts_helpers$con_attend_vs_other$weights) cat(\"\\nWeights for 'con_ignore_vs_other':\\n\") ##  ## Weights for 'con_ignore_vs_other': kable(wts_helpers$con_ignore_vs_other$weights)"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_05_contrasts.html","id":"grouping-contrasts-contrast_set","dir":"Articles","previous_headings":"","what":"Grouping Contrasts: contrast_set","title":"Contrasts in fmrireg","text":"can group multiple contrast specifications using contrast_set. contrast_weights called contrast_set, returns named list computed contrast weight objects.","code":"# Combine several previously defined contrasts all_contrasts <- contrast_set(   con_face_vs_scene,   con_attend_vs_ignore,   con_interaction,   con_face_vs_baseline )  print(all_contrasts) ##  ## === Contrast Set === ##  ##  Overview: ##   * Number of contrasts: 4  ##   * Types of contrasts: ##     - contrast_formula_spec : 1  ##     - pair_contrast_spec : 2  ##     - unit_contrast_spec : 1  ##  ##   Individual Contrasts: ##  ## [1] face_vs_scene (pair_contrast_spec) ##     Formula: ~category == \"face\" vs  ~category == \"scene\" ##  ## [2] attend_vs_ignore (pair_contrast_spec) ##     Formula: ~attention == \"attend\" vs  ~attention == \"ignore\" ##  ## [3] category_X_attention (contrast_formula_spec) ##     Formula: ~(`face:attend` - `face:ignore`) - (`scene:attend` - `scene:ignore`) ##  ## [4] face_gt_baseline (unit_contrast_spec) ##     Formula: ~category == \"face\" # Compute weights for the entire set all_weights <- contrast_weights(all_contrasts, event_term)  # Access weights for a specific contrast within the set cat(\"\\nAccessing weights for 'face_vs_scene' from the set:\\n\") ##  ## Accessing weights for 'face_vs_scene' from the set: kable(all_weights$face_vs_scene$weights)"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_05_contrasts.html","id":"applying-contrasts-in-fmri_lm","dir":"Articles","previous_headings":"","what":"Applying Contrasts in fmri_lm","title":"Contrasts in fmrireg","text":"Contrasts typically specified within hrf() function fmri_lm formula. can provide single contrast specification contrast_set. (Note: fitting code set eval=FALSE avoid lengthy computation vignette build, demonstrates principle.)","code":"# Simulate some simple data for demonstration ysim <- matrix(rnorm(120 * 3), 120, 3) # 3 voxels dataset_sim <- matrix_dataset(ysim, TR = 2, run_length = 120, event_table = design)  # Fit model with the contrast set defined earlier fmri_fit <- fmri_lm(   formula = onset ~ hrf(category, attention, contrasts = all_contrasts),   block = ~ block,   dataset = dataset_sim,   strategy = \"chunkwise\" # Use chunkwise for matrix_dataset )  # Print summary of the fitted model (shows contrasts) print(fmri_fit)"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_05_contrasts.html","id":"extracting-contrast-results","dir":"Articles","previous_headings":"","what":"Extracting Contrast Results","title":"Contrasts in fmrireg","text":"fitting model contrasts, can extract results using standard accessor functions, specifying type = \"contrasts\" type = \"F\": coef(fmri_fit, type = \"contrasts\"): Estimated contrast values. stats(fmri_fit, type = \"contrasts\"): t-statistics contrasts. standard_error(fmri_fit, type = \"contrasts\"): Standard errors contrasts. stats(fmri_fit, type = \"F\"): F-statistics (F-contrasts defined, e.g., via oneway_contrast).","code":"# Extract estimated contrast values contrast_estimates <- coef(fmri_fit, type = \"contrasts\") kable(contrast_estimates, caption = \"Estimated Contrast Values\")  # Extract t-statistics contrast_tstats <- stats(fmri_fit, type = \"contrasts\") kable(contrast_tstats, caption = \"Contrast t-statistics\")  # Extract standard errors contrast_se <- standard_error(fmri_fit, type = \"contrasts\") kable(contrast_se, caption = \"Contrast Standard Errors\")"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_05_contrasts.html","id":"visualizing-contrast-weights","dir":"Articles","previous_headings":"","what":"Visualizing Contrast Weights","title":"Contrasts in fmrireg","text":"plot_contrasts function provides heatmap visualization contrast weights applied across regressors design matrix (including baseline terms present). plot helps verify contrasts specified correctly relative full model design matrix.","code":"# We need to add contrasts *directly* to the event model for plotting emodel_with_cons <- event_model(   onset ~ hrf(category, attention, contrasts = all_contrasts),   block = ~ block,    data = design,    sampling_frame = sframe )  # Plot the contrasts (using default baseline model) tryCatch({   plot_contrasts(emodel_with_cons, rotate_x_text = TRUE, coord_fixed = FALSE) }, error = function(e) {   cat(\"Note: plot_contrasts() encountered an issue and was skipped.\\n\")   cat(\"Error:\", e$message, \"\\n\") }) ## Note: plot_contrasts() encountered an issue and was skipped. ## Error: $ operator is invalid for atomic vectors"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_05_contrasts.html","id":"working-with-contrast-weights","dir":"Articles","previous_headings":"","what":"Working with Contrast Weights","title":"Contrasts in fmrireg","text":"computed contrast weights can used directly statistical analyses exported analysis packages. weights matrix shows exactly experimental condition contributes contrast:","code":"# View the structure of interaction contrast weights cat(\"Interaction contrast structure:\\n\") ## Interaction contrast structure: str(wts_interaction) ## List of 5 ##  $ term         :List of 7 ##   ..$ varname    : chr \"category:attention\" ##   ..$ events     :List of 2 ##   .. ..$ category :List of 7 ##   .. .. ..$ varname   : chr \"category\" ##   .. .. .. ..- attr(*, \"orig_names\")= chr \"category\" ##   .. .. ..$ onsets    : num [1:8] 1 15.1 29.3 43.4 57.6 ... ##   .. .. ..$ durations : num [1:8] 0 0 0 0 0 0 0 0 ##   .. .. ..$ blockids  : int [1:8] 1 1 1 1 1 1 1 1 ##   .. .. ..$ value     : int [1:8, 1] 1 2 1 2 1 2 1 2 ##   .. .. .. ..- attr(*, \"dimnames\")=List of 2 ##   .. .. .. .. ..$ : NULL ##   .. .. .. .. ..$ : chr \"category\" ##   .. .. .. .. .. ..- attr(*, \"orig_names\")= chr \"category\" ##   .. .. ..$ continuous: logi FALSE ##   .. .. ..$ meta      :List of 1 ##   .. .. .. ..$ levels: chr [1:2] \"face\" \"scene\" ##   .. .. ..- attr(*, \"class\")= chr [1:2] \"event\" \"event_seq\" ##   .. ..$ attention:List of 7 ##   .. .. ..$ varname   : chr \"attention\" ##   .. .. .. ..- attr(*, \"orig_names\")= chr \"attention\" ##   .. .. ..$ onsets    : num [1:8] 1 15.1 29.3 43.4 57.6 ... ##   .. .. ..$ durations : num [1:8] 0 0 0 0 0 0 0 0 ##   .. .. ..$ blockids  : int [1:8] 1 1 1 1 1 1 1 1 ##   .. .. ..$ value     : int [1:8, 1] 1 1 2 2 1 1 2 2 ##   .. .. .. ..- attr(*, \"dimnames\")=List of 2 ##   .. .. .. .. ..$ : NULL ##   .. .. .. .. ..$ : chr \"attention\" ##   .. .. .. .. .. ..- attr(*, \"orig_names\")= chr \"attention\" ##   .. .. ..$ continuous: logi FALSE ##   .. .. ..$ meta      :List of 1 ##   .. .. .. ..$ levels: chr [1:2] \"attend\" \"ignore\" ##   .. .. ..- attr(*, \"class\")= chr [1:2] \"event\" \"event_seq\" ##   ..$ subset     : logi [1:8] TRUE TRUE TRUE TRUE TRUE TRUE ... ##   ..$ event_table: tibble [8 × 2] (S3: tbl_df/tbl/data.frame) ##   .. ..$ category : Factor w/ 2 levels \"face\",\"scene\": 1 2 1 2 1 2 1 2 ##   .. ..$ attention: Factor w/ 2 levels \"attend\",\"ignore\": 1 1 2 2 1 1 2 2 ##   ..$ onsets     : num [1:8] 1 15.1 29.3 43.4 57.6 ... ##   ..$ blockids   : int [1:8] 1 1 1 1 1 1 1 1 ##   ..$ durations  : num [1:8] 0 0 0 0 0 0 0 0 ##   ..- attr(*, \"class\")= chr [1:2] \"event_term\" \"event_seq\" ##   ..- attr(*, \"hrfspec\")=List of 15 ##   .. ..$ name     : chr \"category:attention\" ##   .. ..$ label    : chr \"hrf(category,attention)\" ##   .. ..$ id       : NULL ##   .. ..$ vars     :List of 2 ##   .. .. ..$ : language ~category ##   .. .. .. ..- attr(*, \".Environment\")=<environment: 0x5611478b37d0>  ##   .. .. ..$ : language ~attention ##   .. .. .. ..- attr(*, \".Environment\")=<environment: 0x5611478b37d0>  ##   .. .. ..- attr(*, \"class\")= chr [1:2] \"quosures\" \"list\" ##   .. ..$ varnames : Named chr [1:2] \"category\" \"attention\" ##   .. .. ..- attr(*, \"names\")= chr [1:2] \"\" \"\" ##   .. ..$ hrf      :function (t, P1 = 5, P2 = 15, A1 = 0.0833)   ##   .. .. ..- attr(*, \"class\")= chr [1:2] \"HRF\" \"function\" ##   .. .. ..- attr(*, \"name\")= chr \"SPMG1\" ##   .. .. ..- attr(*, \"nbasis\")= int 1 ##   .. .. ..- attr(*, \"span\")= num 24 ##   .. .. ..- attr(*, \"param_names\")= chr [1:3] \"P1\" \"P2\" \"A1\" ##   .. .. ..- attr(*, \"params\")=List of 3 ##   .. .. .. ..$ P1: num 5 ##   .. .. .. ..$ P2: num 15 ##   .. .. .. ..$ A1: num 0.0833 ##   .. ..$ onsets   : NULL ##   .. ..$ durations: NULL ##   .. ..$ prefix   : NULL ##   .. ..$ subset   : NULL ##   .. ..$ precision: num 0.3 ##   .. ..$ contrasts: NULL ##   .. ..$ summate  : logi TRUE ##   .. ..$ uid      : chr \"t01\" ##   .. ..$ term_tag : chr \"category_attention\" ##   .. ..- attr(*, \"class\")= chr [1:2] \"hrfspec\" \"list\" ##   ..- attr(*, \"term_tag\")= chr \"category_attention\" ##   ..- attr(*, \"uid\")= chr \"t01\" ##  $ name         : chr \"category_X_attention\" ##  $ weights      : num [1:4, 1] 1 -1 -1 1 ##   ..- attr(*, \"dimnames\")=List of 2 ##   .. ..$ : chr [1:4] \"category.face_attention.attend\" \"category.scene_attention.attend\" \"category.face_attention.ignore\" \"category.scene_attention.ignore\" ##   .. ..$ : NULL ##  $ condnames    : chr [1:4] \"category.face_attention.attend\" \"category.scene_attention.attend\" \"category.face_attention.ignore\" \"category.scene_attention.ignore\" ##  $ contrast_spec:List of 4 ##   ..$ A    :Class 'formula'  language ~(`face:attend` - `face:ignore`) - (`scene:attend` - `scene:ignore`) ##   .. .. ..- attr(*, \".Environment\")=<environment: R_GlobalEnv>  ##   ..$ B    : NULL ##   ..$ where: NULL ##   ..$ name : chr \"category_X_attention\" ##   ..- attr(*, \"class\")= chr [1:3] \"contrast_formula_spec\" \"contrast_spec\" \"list\" ##  - attr(*, \"class\")= chr [1:2] \"contrast\" \"list\" cat(\"\\nContrast weights matrix:\\n\") ##  ## Contrast weights matrix: print(wts_interaction$conmat) ## NULL"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_05_contrasts.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Contrasts in fmrireg","text":"fmrireg package offers comprehensive system defining applying statistical contrasts fMRI analysis. simple pairwise comparisons (pair_contrast) baseline tests (unit_contrast) complex formula-based definitions (contrast), trend analysis (poly_contrast), ANOVA-style effects (oneway_contrast, interaction_contrast), researchers fine-grained control hypothesis testing. integration fmri_lm visualization tools like plot_contrasts facilitates robust interpretable fMRI modeling.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_08_simulation.html","id":"introduction-to-fmri-data-simulation","dir":"Articles","previous_headings":"","what":"Introduction to fMRI Data Simulation","title":"Simulating fMRI Data","text":"Simulation essential tool fMRI method development, validation, teaching. fmrireg package offers several functions simulate fMRI data varying levels complexity: simulate_bold_signal: Simulates clean BOLD responses multiple experimental conditions simulate_noise_vector: Generates realistic fMRI noise temporal autocorrelation, drift, physiological components simulate_simple_dataset: Combines signal noise complete dataset based SNR simulate_fmri_matrix: Creates multiple time series shared event timing column-specific variation parameters vignette demonstrates use functions create realistic fMRI simulations various purposes.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_08_simulation.html","id":"simulating-clean-bold-signals","dir":"Articles","previous_headings":"","what":"Simulating Clean BOLD Signals","title":"Simulating fMRI Data","text":"Let’s start simulate_bold_signal, generates clean hemodynamic response signal multiple experimental conditions.   function returns list containing: - onset: Event onset times - condition: Condition labels event - mat: Matrix time points BOLD responses condition can control: - Number conditions (ncond) - Number repetitions per condition (nreps) - HRF shape (hrf) - Amplitudes condition (amps) - Inter-stimulus interval range (isi) - Amplitude variability (ampsd)","code":"# Simulate 3 conditions with different amplitudes sim <- simulate_bold_signal(ncond = 3, amps = c(1.0, 1.5, 2.0), TR = 2)  # Extract the data and plot time <- sim$mat[,1]  # First column contains time signals <- sim$mat[,-1]  # Other columns contain condition signals  # Create a tidy dataframe for plotting df <- data.frame(   Time = time,   Cond1 = signals[,1],   Cond2 = signals[,2],   Cond3 = signals[,3] )  df_long <- tidyr::pivot_longer(df, cols = c(Cond1, Cond2, Cond3),                          names_to = \"Condition\",                          values_to = \"Response\")  # Plot using ggplot2 ggplot(df_long, aes(x = Time, y = Response, color = Condition)) +   geom_line() +   theme_minimal() +   labs(title = \"Simulated BOLD Signals for Three Conditions\",        x = \"Time (seconds)\",        y = \"BOLD Response\",        color = \"Condition\") +   scale_color_brewer(palette = \"Set1\") # Mark trial onsets on the time axis ggplot(df_long, aes(x = Time, y = Response, color = Condition)) +   geom_line() +   geom_vline(xintercept = sim$onset, linetype = \"dashed\", alpha = 0.3) +   theme_minimal() +   labs(title = \"Simulated BOLD Signals with Event Onsets\",        x = \"Time (seconds)\",        y = \"BOLD Response\",        color = \"Condition\") +   scale_color_brewer(palette = \"Set1\")"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_08_simulation.html","id":"simulating-realistic-fmri-noise","dir":"Articles","previous_headings":"","what":"Simulating Realistic fMRI Noise","title":"Simulating fMRI Data","text":"simulate_noise_vector function generates realistic fMRI noise combining various noise sources common real fMRI data. understand components, let’s simulate visualize separately combined.     simulation shows five distinct types noise components: White Noise: Random fluctuations equal power across frequencies (flat power spectrum). ARMA Noise: Temporally autocorrelated noise characteristic “smoothed” appearance. power spectrum shows power lower frequencies. Drift Component: slow oscillation typical scanner drift physiological trends. power spectrum shows dominant peak low frequency. Physiological Noise: Regular oscillations frequencies corresponding respiration (~0.3 Hz) cardiac-like activity (~0.8 Hz). real fMRI data TR=2s, cardiac frequencies (~1.2 Hz) aliased. Combined Noise: components together, creating complex noise structure typical real fMRI data. power spectrum shows features contributing components. components, added task-related signals, create realistic fMRI time series.","code":"# Simulation parameters n_timepoints <- 200 TR <- 2 time <- seq(0, (n_timepoints - 1) * TR, by = TR)  # Create noise components with clear differences set.seed(123) # For reproducibility  # 1. Simulate Pure White Noise noise_white <- simulate_noise_vector(n_timepoints, TR = TR,                                    ar = 0, ma = 0,                                   drift_amplitude = 0, physio = FALSE, sd = 1) ## Warning in min(Mod(polyroot(c(1, -model$ar)))): no non-missing arguments to ## min; returning Inf # 2. Simulate ARMA Noise (without drift/physio) noise_arma <- simulate_noise_vector(n_timepoints, TR = TR,                                   ar = c(0.6), ma = c(0.3),                                   drift_amplitude = 0, physio = FALSE, sd = 1)  # 3. Generate Drift Component Directly drift_freq <- 1/128 drift_amplitude <- 2 noise_drift <- drift_amplitude * sin(2 * pi * drift_freq * time)  # 4. Generate Physiological Noise Component Directly # Make physiological components more prominent noise_cardiac <- 1.5 * sin(2 * pi * 0.3 * time)  # Respiratory (~0.3 Hz) noise_respiratory <- 1.0 * sin(2 * pi * 0.8 * time)  # Cardiac-like (~0.8 Hz, observable with TR=2s) noise_physio <- noise_cardiac + noise_respiratory  # 5. Simulate Combined Noise (ARMA + Drift + Physio) noise_combined <- noise_arma + noise_drift + noise_physio  # Combine into a data frame for plotting time courses noise_df <- data.frame(   Time = time,   White_Noise = noise_white,   ARMA_Noise = noise_arma,   Drift_Component = noise_drift,   Physiological_Noise = noise_physio,   Combined_Noise = noise_combined )  # Create long format dataframe for plotting without pipes noise_long <- tidyr::pivot_longer(noise_df,                                    cols = -Time,                                   names_to = \"NoiseType\",                                    values_to = \"Signal\")  # Set factor levels for proper ordering noise_long$NoiseType <- factor(noise_long$NoiseType,                                levels = c(\"White_Noise\", \"ARMA_Noise\",                                          \"Drift_Component\", \"Physiological_Noise\",                                          \"Combined_Noise\"),                               labels = c(\"White Noise\", \"ARMA Noise\",                                          \"Drift Component\", \"Physiological Noise\",                                          \"Combined Noise\"))  # Plot Time Courses (Faceted) ggplot(noise_long, aes(x = Time, y = Signal, color = NoiseType)) +   geom_line() +   facet_wrap(~NoiseType, ncol = 1, scales = \"free_y\") + # Use free_y scales   theme_minimal() +   theme(legend.position = \"none\") + # Remove legend as facets show type   labs(title = \"Simulated fMRI Noise Components: Time Courses\",        x = \"Time (seconds)\",        y = \"Signal Amplitude\") # --- Power Spectrum Analysis --- library(stats)  calculate_spectrum <- function(signal, TR) {   # Detrend   signal <- signal - mean(signal)      # Calculate FFT   n <- length(signal)   # Get proper periodogram-based power spectrum   fft_result <- fft(signal)   # Get power - divide by n to normalize   power <- Mod(fft_result)^2 / n      # Get positive frequencies only (up to Nyquist)   nyquist_index <- floor(n/2) + 1   freq <- seq(0, 1/(2*TR), length.out = nyquist_index)   power_pos <- power[1:nyquist_index]      # For one-sided spectrum, multiply by 2 (except DC and Nyquist)   if (n > 1) {     power_pos[2:(length(power_pos)-ifelse(n %% 2 == 0, 1, 0))] <-        2 * power_pos[2:(length(power_pos)-ifelse(n %% 2 == 0, 1, 0))]   }      # Return as data frame   data.frame(Frequency = freq, Power = power_pos) }  # Calculate spectra spec_white <- calculate_spectrum(noise_white, TR) spec_arma <- calculate_spectrum(noise_arma, TR) spec_drift <- calculate_spectrum(noise_drift, TR) spec_physio <- calculate_spectrum(noise_physio, TR) spec_combined <- calculate_spectrum(noise_combined, TR)  # Add noise type column to each data frame spec_white$NoiseType <- \"White Noise\" spec_arma$NoiseType <- \"ARMA Noise\" spec_drift$NoiseType <- \"Drift Component\" spec_physio$NoiseType <- \"Physiological Noise\" spec_combined$NoiseType <- \"Combined Noise\"  # Combine all spectra into one data frame spec_df <- rbind(spec_white, spec_arma, spec_drift, spec_physio, spec_combined)  # Set factor levels for proper ordering spec_df$NoiseType <- factor(spec_df$NoiseType,                             levels = c(\"White Noise\", \"ARMA Noise\",                                       \"Drift Component\", \"Physiological Noise\",                                       \"Combined Noise\"))  # Create better drift visualization # First, generate a longer drift signal to better resolve low frequencies n_long <- 1024 time_long <- seq(0, (n_long - 1) * TR, by = TR) drift_long <- drift_amplitude * sin(2 * pi * drift_freq * time_long) spec_drift_long <- calculate_spectrum(drift_long, TR) spec_drift_long$NoiseType <- \"Drift Component (High Resolution)\"  # Plot Power Spectra in regular scale to show true spectral shape ggplot() +   # Regular components   geom_line(data = spec_df, aes(x = Frequency, y = Power, color = NoiseType)) +   # Add high-resolution drift component   geom_line(data = subset(spec_drift_long, Frequency <= 0.05),             aes(x = Frequency, y = Power), color = \"darkgreen\", linetype = \"dashed\") +   theme_minimal() +   facet_wrap(~NoiseType, ncol = 1, scales = \"free_y\") +   theme(legend.position = \"none\") +   labs(title = \"Power Spectra of Different Noise Components\",        x = \"Frequency (Hz)\",        y = \"Power\") +   scale_color_brewer(palette = \"Set1\") +   coord_cartesian(xlim = c(0, 0.25))  # Limit to Nyquist frequency # Also plot with log scale to show all components together ggplot(spec_df, aes(x = Frequency, y = Power, color = NoiseType)) +   geom_line() +   theme_minimal() +   labs(title = \"Power Spectra of Different Noise Components (Log Scale)\",        x = \"Frequency (Hz)\",        y = \"Power (log scale)\") +   scale_y_log10() +  # Log scale to see all components   scale_color_brewer(palette = \"Set1\") +   theme(legend.position = \"top\") +   coord_cartesian(xlim = c(0, 0.25))  # Limit to Nyquist frequency # Special zoom-in plot to focus on drift component drift_freq_idx <- which.min(abs(spec_df$Frequency - drift_freq)) ggplot() +   geom_line(data = subset(spec_df, NoiseType == \"Drift Component\"),             aes(x = Frequency, y = Power), color = \"darkgreen\") +   geom_line(data = subset(spec_drift_long, Frequency <= 0.05),             aes(x = Frequency, y = Power), color = \"darkgreen\", linetype = \"dashed\") +   geom_vline(xintercept = drift_freq, linetype = \"dotted\", color = \"red\") +   theme_minimal() +   labs(title = \"Zoomed Power Spectrum of Drift Component\",        subtitle = paste(\"Expected peak at\", drift_freq, \"Hz\"),        x = \"Frequency (Hz)\",        y = \"Power\") +   coord_cartesian(xlim = c(0, 0.05))  # Zoom in on low frequencies"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_08_simulation.html","id":"creating-a-complete-dataset-with-signal-and-noise","dir":"Articles","previous_headings":"","what":"Creating a Complete Dataset with Signal and Noise","title":"Simulating fMRI Data","text":"simulate_simple_dataset function combines clean signals noise create complete fMRI dataset specified signal--noise ratio (SNR).     Statistics clean noisy signals different SNR levels visualization shows different SNR levels affect fMRI time series. lower SNR, noise dominates signal. SNR level, show: original clean signal (red line): true underlying BOLD response noisy signal (blue line): actually measured scanner Signal decomposition: Visualization signal, noise, combined signal relate SNR level SNR = 1.0, signal pattern remains clearly visible despite noise. SNR = 0.5, features signal obscured, SNR = 0.2, noise substantially masks underlying signal, making accurate detection challenging without proper statistical methods. function returns: - clean: simulated signals without noise - noisy: signals added noise - noise: simulated noise component - onsets: Trial onset times - conditions: Condition labels trial","code":"# Set seed for reproducibility set.seed(42)  # Simulate a dataset with 3 conditions and different SNR levels data_snr_1.0 <- simulate_simple_dataset(ncond = 3, TR = 2, snr = 1.0) data_snr_0.5 <- simulate_simple_dataset(ncond = 3, TR = 2, snr = 0.5) data_snr_0.2 <- simulate_simple_dataset(ncond = 3, TR = 2, snr = 0.2)  # Improved function to create data frame for plotting create_plot_df <- function(data, snr_label) {   time <- data$clean$mat[,1]      # Extract clean signals and noisy signals    # Instead of averaging, use the condition with the clearest signal pattern   # Usually the middle column has the most distinct pattern   best_column <- which.max(apply(data$clean$mat[,-1], 2, function(x) max(x) - min(x)))   clean_signal <- data$clean$mat[, best_column + 1]  # +1 because column 1 is time   noisy_signal <- data$noisy[, best_column + 1]      # Corresponding noisy signal      df <- data.frame(     Time = time,     Clean = clean_signal,     Noisy = noisy_signal,     SNR = snr_label   )      return(df) }  # Combine data for different SNR values plot_df <- rbind(   create_plot_df(data_snr_1.0, \"SNR = 1.0\"),   create_plot_df(data_snr_0.5, \"SNR = 0.5\"),   create_plot_df(data_snr_0.2, \"SNR = 0.2\") )  # Convert to long format plot_df_long <- tidyr::pivot_longer(plot_df,                                      cols = -c(Time, SNR),                                     names_to = \"Type\",                                      values_to = \"Signal\")  # First approach: Overlay clean and noisy signals ggplot(plot_df_long, aes(x = Time, y = Signal, color = Type)) +   geom_line() +   facet_wrap(~SNR, ncol = 1) +   theme_minimal() +   labs(title = \"Clean vs. Noisy Signals at Different SNR Levels\",        subtitle = \"Single condition shown for clarity\",        x = \"Time (seconds)\",        y = \"Signal\",        color = \"Signal Type\") +   scale_color_manual(values = c(\"Clean\" = \"darkred\", \"Noisy\" = \"steelblue\")) +   theme(legend.position = \"top\") # Second approach: Plot signal+noise and then just signal below it # Create custom panel plots for each SNR plot_faceted <- function(df, snr_value) {   df_subset <- subset(df, SNR == snr_value)      # Calculate the noise component   noise <- df_subset$Noisy - df_subset$Clean      # Create a data frame for the decomposition plot   decomp_df <- data.frame(     Time = rep(df_subset$Time, 3),     Component = factor(rep(c(\"Signal+Noise\", \"Signal\", \"Noise\"), each = length(df_subset$Time)),                       levels = c(\"Signal+Noise\", \"Signal\", \"Noise\")),     Value = c(df_subset$Noisy, df_subset$Clean, noise)   )      # Plot with custom y-axis ranges   ggplot(decomp_df, aes(x = Time, y = Value, color = Component)) +     geom_line() +     facet_wrap(~Component, ncol = 1, scales = \"free_y\") +     theme_minimal() +     labs(title = paste(\"Signal Decomposition at\", snr_value),          x = \"Time (seconds)\",          y = \"Amplitude\") +     scale_color_manual(values = c(\"Signal+Noise\" = \"steelblue\",                                   \"Signal\" = \"darkred\",                                   \"Noise\" = \"darkgreen\")) +     theme(legend.position = \"none\") }  # Create each SNR plot p1 <- plot_faceted(plot_df, \"SNR = 1.0\") p2 <- plot_faceted(plot_df, \"SNR = 0.5\") p3 <- plot_faceted(plot_df, \"SNR = 0.2\")  # Display plots in sequence p1 p2 p3 # Calculate statistics (using standard R to avoid pipe operator issues) snr_stats_list <- list() for (snr_val in unique(plot_df_long$SNR)) {   for (type_val in unique(plot_df_long$Type)) {     subset_data <- plot_df_long[plot_df_long$SNR == snr_val & plot_df_long$Type == type_val, ]     snr_stats_list[[length(snr_stats_list) + 1]] <- data.frame(       SNR = snr_val,       Type = type_val,       Mean = mean(subset_data$Signal),       SD = sd(subset_data$Signal),       Range = max(subset_data$Signal) - min(subset_data$Signal)     )   } } snr_stats <- do.call(rbind, snr_stats_list)  # Print the statistics knitr::kable(snr_stats, caption = \"Statistics of clean and noisy signals at different SNR levels\")"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_08_simulation.html","id":"simulating-matrix-time-series-with-column-specific-variation","dir":"Articles","previous_headings":"","what":"Simulating Matrix Time Series with Column-Specific Variation","title":"Simulating fMRI Data","text":"advanced simulation function, simulate_fmri_matrix, generates multiple time series (columns) share event timing column-specific variations amplitudes durations. particularly useful simulating multiple voxels regions related slightly different response profiles.    function particularly powerful simulating multiple related time series : - Shared event timing individual variation : - Amplitude (per event, per column) - Duration (per event, per column) - Independent noise generation column - Complex output including: - Time series matrix - Amplitude duration matrices - HRF noise parameter information","code":"# Simulate 5 voxels (columns) with shared event timing # but variation in amplitudes and durations sim_matrix <- simulate_fmri_matrix(   n = 5,                  # 5 voxels/regions   total_time = 200,       # 200 seconds of scan time   TR = 2,                 # TR = 2 seconds   n_events = 10,          # 10 events   amplitudes = 1,         # Base amplitude = 1   amplitude_sd = 0.3,     # Amplitude variability   durations = 2,          # Base duration = 2 seconds   duration_sd = 0.5,      # Duration variability   noise_type = \"ar1\",     # AR(1) noise   noise_sd = 0.5          # Noise standard deviation )  # Extract the time series data ts_data <- sim_matrix$time_series matrix_data <- ts_data$datamat  # Create a tidy data frame for plotting time_points <- seq(0, by = 2, length.out = nrow(matrix_data)) plot_data <- data.frame(Time = time_points)  for(i in 1:ncol(matrix_data)) {   plot_data[[paste0(\"Voxel\", i)]] <- matrix_data[, i] }  plot_data_long <- tidyr::pivot_longer(   plot_data,    cols = starts_with(\"Voxel\"),    names_to = \"Voxel\",    values_to = \"Signal\" )  # Plot all time series ggplot(plot_data_long, aes(x = Time, y = Signal, color = Voxel)) +   geom_line(alpha = 0.8) +   theme_minimal() +   labs(title = \"Multiple Simulated Time Series with Column-Specific Variation\",        x = \"Time (seconds)\",        y = \"Signal\",        color = \"Voxel\") +   scale_color_brewer(palette = \"Set2\") # Plot the amplitude and duration matrices to visualize trial-by-trial variations amp_df <- as.data.frame(sim_matrix$ampmat) colnames(amp_df) <- paste0(\"Voxel\", 1:ncol(amp_df)) amp_df$Event <- 1:nrow(amp_df)  dur_df <- as.data.frame(sim_matrix$durmat) colnames(dur_df) <- paste0(\"Voxel\", 1:ncol(dur_df)) dur_df$Event <- 1:nrow(dur_df)  # Transform to long format amp_long <- tidyr::pivot_longer(   amp_df,    cols = starts_with(\"Voxel\"),    names_to = \"Voxel\",    values_to = \"Amplitude\" )  dur_long <- tidyr::pivot_longer(   dur_df,    cols = starts_with(\"Voxel\"),    names_to = \"Voxel\",    values_to = \"Duration\" )  # Plot amplitude variation across voxels ggplot(amp_long, aes(x = Event, y = Amplitude, color = Voxel, group = Voxel)) +   geom_line() +   geom_point() +   theme_minimal() +   labs(title = \"Amplitude Variation Across Events and Voxels\",        x = \"Event Number\",        y = \"Amplitude\",        color = \"Voxel\") +   scale_color_brewer(palette = \"Set2\") # Plot duration variation across voxels ggplot(dur_long, aes(x = Event, y = Duration, color = Voxel, group = Voxel)) +   geom_line() +   geom_point() +   theme_minimal() +   labs(title = \"Duration Variation Across Events and Voxels\",        x = \"Event Number\",        y = \"Duration (seconds)\",        color = \"Voxel\") +   scale_color_brewer(palette = \"Set2\")"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_08_simulation.html","id":"summary-and-comparison","dir":"Articles","previous_headings":"","what":"Summary and Comparison","title":"Simulating fMRI Data","text":"four simulation functions fmrireg serve different purposes offer increasing levels complexity: simulate_bold_signal: Generate clean BOLD signals multiple conditions simulate_noise_vector: Create realistic fMRI noise temporal structure simulate_simple_dataset: Combine signal noise specific SNR simulate_fmri_matrix: Create multiple time series trial--trial, column-specific parameter variation Choose appropriate function based simulation needs: - basic signal generation: use simulate_bold_signal - realistic noise: use simulate_noise_vector - complete dataset controlled SNR: use simulate_simple_dataset - simulating multiple voxels/regions shared timing response variation: use simulate_fmri_matrix functions provide powerful toolkit method development, validation, teaching fMRI analysis concepts realistic simulations.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_09_linear_model.html","id":"introduction-to-fmri-linear-models","dir":"Articles","previous_headings":"","what":"Introduction to fMRI Linear Models","title":"fMRI Linear Model Analysis","text":"Statistical analysis fMRI data typically involves fitting linear model voxel’s time series. approach, often called General Linear Model (GLM), estimates much experimental condition contributes observed signal. fmrireg package provides flexible framework : Modeling hemodynamic response experimental stimuli Accounting baseline trends noise Estimating condition-specific effects Computing contrasts conditions Testing statistical hypotheses brain activity Thread usage internal routines can adjusted globally. Set options(fmrireg.num_threads = <n>) environment variable FMRIREG_NUM_THREADS loading package control many threads RcppParallel uses. vignette demonstrates conduct complete linear model analysis using fmrireg package, data simulation statistical inference.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_09_linear_model.html","id":"simulating-a-dataset-for-analysis","dir":"Articles","previous_headings":"","what":"Simulating a Dataset for Analysis","title":"fMRI Linear Model Analysis","text":"First, let’s create realistic fMRI dataset known parameters. ’ll simulate simple experiment two conditions different amplitudes. First rows experimental design  Now experimental design, let’s simulate fMRI time series. ’ll create signals condition different amplitudes, add noise, combine dataset.  simulated dataset now contains: Condition-specific signals known amplitudes (1.0 2.0) Realistic noise temporal autocorrelation, drift, physiological components Multiple “voxels” varying signal strengths complete event table condition labels onset times","code":"# Create an experimental design with two conditions # Condition 1: 10 events with amplitude 1.0 # Condition 2: 10 events with amplitude 2.0  # Define parameters TR <- 2                  # Repetition time (2 seconds) run_length <- 200        # 200 timepoints per run = 400 seconds nruns <- 1               # Number of runs  # Create an event table run_id <- rep(1, 20) condition <- factor(rep(c(\"condition1\", \"condition2\"), each = 10)) onset_times <- sort(runif(20, min = 10, max = 380))  # Random onsets between 10s and 380s  event_table <- data.frame(   run = run_id,   onset = onset_times,   condition = condition )  # Display the experiment design kable(head(event_table), caption = \"First few rows of the experimental design\") # Create a sampling frame sframe <- sampling_frame(blocklens = run_length, TR = TR)  # Visualize the experimental design event_df <- data.frame(   time = seq(0, (run_length-1) * TR, by = TR),   condition1 = rep(0, run_length),   condition2 = rep(0, run_length) )  # Mark event onsets in the timeline for (i in 1:nrow(event_table)) {   timepoint <- which.min(abs(event_df$time - event_table$onset[i]))   if (event_table$condition[i] == \"condition1\") {     event_df$condition1[timepoint] <- 1   } else {     event_df$condition2[timepoint] <- 1   } }  # Convert to long format for plotting event_long <- event_df %>%   pivot_longer(cols = -time, names_to = \"condition\", values_to = \"onset\")  # Plot the experimental design ggplot(event_long, aes(x = time, y = onset, color = condition)) +   geom_segment(aes(xend = time, yend = 0), linewidth = 1) +   geom_point(size = 3) +   theme_minimal(base_size = 14) +   theme(legend.position = \"top\",         text = element_text(size = 14),         axis.title = element_text(size = 15),         plot.title = element_text(size = 16)) +   labs(title = \"Experimental Design with Event Onsets\",        x = \"Time (seconds)\",        y = \"Event\") +   scale_color_brewer(palette = \"Set1\") # Simulate the true BOLD signals for each condition # First, convert our events to global indices global_onsets <- global_onsets(sframe, event_table$onset, blockids(sframe)[event_table$run])  # Create regressors for each condition condition1_indices <- which(event_table$condition == \"condition1\") condition2_indices <- which(event_table$condition == \"condition2\")  reg1 <- regressor(global_onsets[condition1_indices], hrf = fmrihrf::HRF_SPMG1, amplitude = 1.0) reg2 <- regressor(global_onsets[condition2_indices], hrf = fmrihrf::HRF_SPMG1, amplitude = 2.0)  # Sample time points time_points <- samples(sframe, global = TRUE)  # Evaluate regressors at each time point signal1 <- evaluate(reg1, time_points) signal2 <- evaluate(reg2, time_points)  # Combine signals (this is the \"true\" signal without noise) true_signal <- signal1 + signal2  # Create noise with temporal autocorrelation and drift noise <- simulate_noise_vector(   n = length(time_points),   TR = TR,   ar = c(0.3),         # AR coefficient (temporal autocorrelation)   ma = c(0.2),         # MA coefficient   drift_freq = 1/128,  # Slow drift   drift_amplitude = 1, # Moderate drift amplitude   physio = TRUE,       # Include physiological noise   sd = 0.5             # Noise standard deviation )  # Create the observed signal by adding noise observed_signal <- true_signal + noise  # Create a data frame for visualization signal_df <- data.frame(   time = time_points,   true_signal = true_signal,   noise = noise,   observed_signal = observed_signal,   condition1 = signal1,   condition2 = signal2 )  # Create a matrix dataset for the model fitting simulated_data <- matrix(observed_signal, ncol = 1) dataset <- fmridataset::matrix_dataset(   datamat = cbind(simulated_data, simulated_data * 0.8, simulated_data * 0.6), # Three \"voxels\" with varied signal strength   TR = TR,   run_length = run_length,   event_table = event_table )  # Visualize the signals signal_long <- signal_df %>%   select(time, condition1, condition2, true_signal, noise, observed_signal) %>%   pivot_longer(cols = -time, names_to = \"component\", values_to = \"signal\")  # Set the factor levels for better plotting order signal_long$component <- factor(signal_long$component,                                 levels = c(\"condition1\", \"condition2\", \"true_signal\", \"noise\", \"observed_signal\"))  # Plot signals ggplot(signal_long, aes(x = time, y = signal, color = component)) +   geom_line() +   facet_wrap(~component, ncol = 1, scales = \"free_y\") +   theme_minimal(base_size = 14) +   theme(legend.position = \"none\",         text = element_text(size = 14),         axis.title = element_text(size = 15),         plot.title = element_text(size = 16),         strip.text = element_text(size = 14)) +   labs(title = \"Simulated fMRI Time Series Components\",        x = \"Time (seconds)\",        y = \"Signal Amplitude\")"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_09_linear_model.html","id":"fitting-a-linear-model","dir":"Articles","previous_headings":"","what":"Fitting a Linear Model","title":"fMRI Linear Model Analysis","text":"Now can fit linear model simulated data using fmri_lm function. need specify: formula describing experimental effects block structure data dataset","code":"# Fit a linear model model <- fmri_lm(   formula = onset ~ hrf(condition),  # Model experimental effects   block = ~ run,                     # Block structure   dataset = dataset,                 # Our simulated dataset   strategy = \"chunkwise\",            # Processing strategy   nchunks = 1                        # Process all voxels at once )  # Print a summary of the model model ##  ## ================================== ##         fmri_lm_result           ## ================================== ##  ## Model formula: ##   ~ onset hrf(condition)  ##  ## Fitting strategy:  chunkwise  ##  ## Baseline parameters:  4  ## Design parameters:    2  ## Contrasts:           None ##  ## Use coef(...), stats(...), etc. to extract results. ##  ##"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_09_linear_model.html","id":"accounting-for-temporal-autocorrelation","dir":"Articles","previous_headings":"Fitting a Linear Model","what":"Accounting for Temporal Autocorrelation","title":"fMRI Linear Model Analysis","text":"simulated noise contains AR(1) structure. can ask fmri_lm apply fast AR(1) prewhitening step setting cor_struct = \"ar1\". estimates AR coefficient initial OLS fit, whitens data design matrix, refits GLM. cor_struct argument also accepts \"arp\" higher-order autoregressive models. setting models AR coefficients (moving-average terms).","code":"model_ar1 <- fmri_lm(   formula = onset ~ hrf(condition),   block   = ~ run,   dataset = dataset,   strategy = \"chunkwise\",   nchunks = 1,   cor_struct = \"ar1\",   cor_iter = 1 )  # Compare standard errors (first few voxels) se_ols <- standard_error(model) se_ar1 <- standard_error(model_ar1) head(cbind(OLS = se_ols[[1]], AR1 = se_ar1[[1]])) ##             OLS        AR1 ## [1,] 0.11620215 0.11620215 ## [2,] 0.09296172 0.09296172 ## [3,] 0.06972129 0.06972129"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_09_linear_model.html","id":"handling-outliers-with-row-wise-robust-fitting","dir":"Articles","previous_headings":"Fitting a Linear Model","what":"Handling Outliers with Row-Wise Robust Fitting","title":"fMRI Linear Model Analysis","text":"Real fMRI runs sometimes contain entire time points corrupted motion scanner artifacts. fmri_lm function can mitigate impact enabling row-wise robust weighting. robust = TRUE, Iteratively Reweighted Least Squares loop -weights frames large residuals. robust_psi argument selects weighting function robust_max_iter controls number iterations. Robust fitting guards outlier time points correct voxel-specific spikes. P-values rely robust residual scale interpreted approximate.","code":"# Note: Robust fitting example - requires bug fix in chunkwise_lm_slow model_robust <- fmri_lm(   formula = onset ~ hrf(condition),   block   = ~ run,   dataset = dataset,   strategy = \"chunkwise\",   nchunks = 1,   robust = TRUE,   robust_psi = \"huber\",   robust_max_iter = 2 )  se_robust <- standard_error(model_robust) head(cbind(OLS = se_ols[[1]], Robust = se_robust[[1]]))"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_09_linear_model.html","id":"extracting-model-results","dir":"Articles","previous_headings":"","what":"Extracting Model Results","title":"fMRI Linear Model Analysis","text":"Let’s extract visualize results linear model.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_09_linear_model.html","id":"coefficient-estimates","dir":"Articles","previous_headings":"Extracting Model Results","what":"1. Coefficient Estimates","title":"fMRI Linear Model Analysis","text":"Coefficient estimates condition voxel  bar plot shows estimated coefficients condition across three simulated voxels. Note : Condition2 approximately twice amplitude Condition1, matches simulation parameters coefficient magnitude decreases across voxels, consistent multiplication factors (1.0, 0.8, 0.6)","code":"# Extract coefficient estimates beta_estimates <- coef(model) kable(beta_estimates, caption = \"Coefficient estimates for each condition and voxel\") # Reshape for plotting (works with both approaches) beta_long <- as.data.frame(beta_estimates) %>%   mutate(voxel = row_number()) %>%   pivot_longer(cols = -voxel, names_to = \"condition\", values_to = \"estimate\")  # Plot coefficient estimates ggplot(beta_long, aes(x = condition, y = estimate, fill = condition)) +   geom_bar(stat = \"identity\") +   facet_wrap(~voxel, ncol = 3, scales = \"free_y\") +   theme_minimal(base_size = 14) +   theme(legend.position = \"top\",         text = element_text(size = 14),         axis.title = element_text(size = 15),         plot.title = element_text(size = 16),         strip.text = element_text(size = 14),         axis.text.x = element_text(angle = 45, hjust = 1)) +   labs(title = \"Estimated Coefficients by Condition and Voxel\",        x = \"Condition\",        y = \"Coefficient Estimate\")"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_09_linear_model.html","id":"t-statistics-and-p-values","dir":"Articles","previous_headings":"Extracting Model Results","what":"2. T-Statistics and P-Values","title":"fMRI Linear Model Analysis","text":"t-statistics quantify reliability estimated effects. Higher absolute t-values indicate reliable estimates. simulation, conditions voxels show significant activity (p < 0.05).","code":"# Extract t-statistics and standard errors t_stats <- stats(model) std_errors <- standard_error(model) # Note: Statistical results visualization - requires proper stats() method implementation # Display the statistical results kable(t_stats, caption = \"T-statistics for each condition and voxel\") kable(std_errors, caption = \"Standard errors for each condition and voxel\")  # The following code would combine and visualize statistical results: # result_summary <- data.frame( #   voxel = rep(1:nrow(beta_estimates), ncol(beta_estimates)), #   condition = rep(colnames(beta_estimates), each = nrow(beta_estimates)), #   estimate = as.vector(as.matrix(beta_estimates)), #   t_statistic = as.vector(t_stats), #   std_error = as.vector(std_errors) # ) # result_summary$p_value <- 2 * pt(-abs(result_summary$t_statistic), df = run_length - 2) # ... visualization code ..."},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_09_linear_model.html","id":"contrasts-between-conditions","dir":"Articles","previous_headings":"Extracting Model Results","what":"3. Contrasts Between Conditions","title":"fMRI Linear Model Analysis","text":"key advantage GLM approach ability directly compare conditions using contrasts. contrast results show Condition2 consistently elicits significantly stronger activation Condition1 across voxels, matches simulation parameters (Condition2 twice amplitude Condition1).","code":"# Note: Contrast analysis example - requires bug fix in event_model parsing # Define a contrast specification for comparing condition2 vs condition1 con_spec <- pair_contrast(~ condition == \"condition2\", ~ condition == \"condition1\", name = \"cond2_minus_cond1\")  # Define a contrast model using the specified contrast in hrf() contrast_model <- fmri_lm(   formula = onset ~ hrf(condition, contrasts = con_spec),   block = ~ run,   dataset = dataset,   strategy = \"chunkwise\",   nchunks = 1 )  # Extract contrast results contrast_estimates <- coef(contrast_model) contrast_tstats <- stats(contrast_model) contrast_stderr <- standard_error(contrast_model)  # Combine results into a data frame for display contrast_results <- data.frame(   voxel = 1:nrow(contrast_estimates),   estimate = contrast_estimates[[1]],   t_statistic = contrast_tstats[[1]],   std_error = contrast_stderr[[1]] )  # Calculate p-values and significance contrast_results$p_value <- 2 * pt(-abs(contrast_results$t_statistic), df = run_length - 2) contrast_results$significant <- contrast_results$p_value < 0.05 # Display contrast results kable(contrast_results, caption = \"Contrast results: condition2 - condition1\", digits = 4)  # Visualize the contrast ggplot(contrast_results, aes(x = as.factor(voxel), y = estimate, fill = significant)) +   geom_bar(stat = \"identity\") +   theme_minimal(base_size = 14) +   theme(text = element_text(size = 14),         axis.title = element_text(size = 15),         plot.title = element_text(size = 16),         plot.subtitle = element_text(size = 15)) +   labs(title = \"Condition2 - Condition1 Contrast\",        subtitle = \"Positive values indicate stronger activation for Condition2\",        x = \"Voxel\",        y = \"Contrast Estimate\") +   scale_fill_manual(values = c(\"FALSE\" = \"gray\", \"TRUE\" = \"red\"))"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_09_linear_model.html","id":"fitted-hrf-curves","dir":"Articles","previous_headings":"","what":"Fitted HRF Curves","title":"fMRI Linear Model Analysis","text":"Another useful visualization fitted hemodynamic response condition. shows estimated BOLD response time. fitted HRF curves show temporal profile BOLD response condition. can observe: peak response around 5-6 seconds post-stimulus stronger response Condition2 compared Condition1 decreasing response amplitude across voxels","code":"# Note: fitted_hrf example - requires contrast_model to be created # Extract fitted HRF curves fitted_hrfs <- fitted_hrf(contrast_model, sample_at = seq(0, 20, by = 0.5))  # Extract the design info and reorganize for plotting hrf_data <- lapply(names(fitted_hrfs), function(term) {   hrf_info <- fitted_hrfs[[term]]   design_info <- hrf_info$design   pred_values <- hrf_info$pred      # Combine with design info   result <- cbind(design_info, pred_values)   result$term <- term   return(result) })  # Combine all HRF data hrf_df <- do.call(rbind, hrf_data)  # Find the column names that contain the predicted values (likely numbered columns) pred_cols <- grep(\"^[0-9]+$\", colnames(hrf_df), value = TRUE) if (length(pred_cols) == 0) {   # Try another pattern that might match the columns   pred_cols <- grep(\"^X[0-9]+$\", colnames(hrf_df), value = TRUE) }  # Create a data frame in long format for plotting hrf_long <- hrf_df %>%   tidyr::pivot_longer(     cols = all_of(pred_cols),     names_to = \"voxel_id\",     values_to = \"response\"   ) %>%   mutate(voxel = paste0(\"voxel\", as.numeric(gsub(\"X\", \"\", voxel_id))))  # Plot the fitted HRF curves for each condition and voxel ggplot(hrf_long, aes(x = time, y = response, color = condition)) +   geom_line() +   facet_grid(voxel ~ term) +   theme_minimal(base_size = 14) +   theme(text = element_text(size = 14),         axis.title = element_text(size = 15),         plot.title = element_text(size = 16),         strip.text = element_text(size = 14)) +   labs(title = \"Fitted Hemodynamic Response Functions\",        x = \"Time (seconds)\",        y = \"BOLD Response\",        color = \"Condition\")"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_09_linear_model.html","id":"comparing-models-with-different-hrf-bases","dir":"Articles","previous_headings":"","what":"Comparing Models with Different HRF Bases","title":"fMRI Linear Model Analysis","text":"choice hemodynamic response function can impact model fit. Let’s compare different HRF options. model comparison shows: R-Squared: proportion variance explained model. Higher values indicate better fit. AIC (Akaike Information Criterion): measure model quality balances goodness fit model complexity. Lower values indicate better models. case, canonical (SPM) model actually provides best fit according AIC, showing lowest AIC values across voxels. interesting result since used HRF (SPMG1) generate data, confirming model selection correctly identifies true underlying signal generator. B-spline model, despite flexibility capture variations signal, penalized AIC additional complexity. demonstrates model selection criteria like AIC can help identify parsimonious model explains data. canonical SPM model performs well due accurate representation hemodynamic response shape simulated data, making optimal choice particular dataset. highlights importance selecting appropriate HRF basis function analyzing fMRI data.","code":"# Note: HRF comparison example - requires fix in model fitting # Fit models with different HRF bases model_canonical <- fmri_lm(   formula = onset ~ hrf(condition, basis = \"spmg1\"),   block = ~ run,   dataset = dataset,   strategy = \"chunkwise\",   nchunks = 1 )  model_gaussian <- fmri_lm(   formula = onset ~ hrf(condition, basis = \"gaussian\"),   block = ~ run,   dataset = dataset,   strategy = \"chunkwise\",   nchunks = 1 )  model_bspline <- fmri_lm(   formula = onset ~ hrf(condition, basis = \"bspline\", nbasis = 5),   block = ~ run,   dataset = dataset,   strategy = \"chunkwise\",   nchunks = 1 )  # Function to extract model fit statistics extract_model_stats <- function(model, model_name, dataset) {   # Get observed data   observed_data <- get_data_matrix(dataset)      # Get design matrix (ensure it's a numeric matrix)   design_mat <- as.matrix(design_matrix(model$model))      # Get estimated coefficients (include baseline)   # Get all coefficients including baseline   betas <- as.matrix(coef(model))      # Calculate fitted values   fitted_vals <- design_mat %*% t(betas)      # Calculate residuals   resids <- observed_data - fitted_vals      # Calculate sum of squared residuals   ssr <- colSums(resids^2)      # Calculate R-squared   tss <- apply(observed_data, 2, function(y) sum((y - mean(y))^2))   r_squared <- 1 - ssr/tss      # Calculate AIC   n <- nrow(observed_data)   p <- ncol(design_mat)   aic <- n * log(ssr/n) + 2 * p      # Return results   data.frame(     model = model_name,     voxel = 1:ncol(observed_data),     r_squared = r_squared,     aic = aic,     ssr = ssr   ) }  # Extract statistics for each model stats_canonical <- extract_model_stats(model_canonical, \"canonical_spm\", dataset) stats_gaussian <- extract_model_stats(model_gaussian, \"gaussian\", dataset) stats_bspline <- extract_model_stats(model_bspline, \"bspline_n5\", dataset)  # Combine results model_comparison <- rbind(stats_canonical, stats_gaussian, stats_bspline)  # Display model comparison kable(model_comparison, caption = \"Model comparison statistics\", digits = 4)  # Reshape for plotting model_comparison_long <- model_comparison %>%   pivot_longer(cols = c(r_squared, aic, ssr), names_to = \"metric\", values_to = \"value\")  # Plot comparison (separate plots for different metrics) ggplot(subset(model_comparison_long, metric == \"r_squared\"),         aes(x = model, y = value, fill = model)) +   geom_bar(stat = \"identity\") +   facet_wrap(~voxel, ncol = 3) +   theme_minimal(base_size = 14) +   theme(text = element_text(size = 14),         axis.title = element_text(size = 15),         plot.title = element_text(size = 16),         strip.text = element_text(size = 14),         axis.text.x = element_text(angle = 45, hjust = 1),         legend.position = \"none\") +   labs(title = \"Model Comparison: R-Squared\",        x = \"HRF Model\",        y = \"R-Squared\") # Note: AIC comparison visualization - requires model_comparison_long ggplot(subset(model_comparison_long, metric == \"aic\"),         aes(x = model, y = value, fill = model)) +   geom_bar(stat = \"identity\") +   facet_wrap(~voxel, ncol = 3) +   theme_minimal(base_size = 14) +   theme(text = element_text(size = 14),         axis.title = element_text(size = 15),         plot.title = element_text(size = 16),         strip.text = element_text(size = 14),         axis.text.x = element_text(angle = 45, hjust = 1),         legend.position = \"none\") +   labs(title = \"Model Comparison: AIC (Lower is Better)\",        x = \"HRF Model\",        y = \"AIC\")"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_09_linear_model.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"fMRI Linear Model Analysis","text":"vignette demonstrated complete workflow fMRI linear model analysis using fmrireg package: Creating/simulating dataset realistic signal noise properties Fitting linear models different HRF options Extracting visualizing model coefficients statistics Computing testing contrasts conditions Comparing model performance using goodness--fit metrics Diagnosing model quality residual analysis fmri_lm function provides powerful flexible framework analyzing fMRI data, features handling temporal autocorrelation, modeling different HRF shapes, computing contrasts conditions. advanced analyses, might consider: - Adding nuisance regressors model physiological noise, motion, confounds - Using complex experimental designs multiple factors - Implementing spatial smoothing preprocessing steps - Extending GLM methods like psychophysiological interactions (PPI) finite impulse response (FIR) models","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_10_dataset.html","id":"introduction-linking-data-and-design","dir":"Articles","previous_headings":"","what":"Introduction: Linking Data and Design","title":"Representing fMRI Data in fmrireg","text":"Effective fMRI analysis requires associating measured brain activity (imaging data) crucial metadata, including: Temporal Structure: scan acquired (TR) scans grouped runs. Spatial Structure: brain locations (voxels) included analysis (mask). Experimental Design: Timing properties experimental events conditions. fmrireg package uses several dataset objects encapsulate information, providing consistent input format modeling functions like event_model, baseline_model, fmri_lm, estimate_betas. vignette describes main dataset classes create .","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_10_dataset.html","id":"the-sampling_frame","dir":"Articles","previous_headings":"","what":"The sampling_frame","title":"Representing fMRI Data in fmrireg","text":"diving datasets, recall sampling_frame object (introduced Overview detailed vignettes). defines fundamental temporal structure shared dataset types: blocklens: vector specifying number scans (time points) run. TR: repetition time (time scans) seconds. Dataset objects internally create utilize sampling_frame based provided run lengths TR.","code":"sframe_example <- sampling_frame(blocklens = c(150, 160), TR = 2.0) print(sframe_example) #> Sampling Frame #> ============== #>  #> Structure: #>   2 blocks #>   Total scans: 310 #>  #> Timing: #>   TR: 2 s #>   Precision: 0.1 s #>  #> Duration: #>   Total time: 620.0 s"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_10_dataset.html","id":"overview-of-dataset-classes","dir":"Articles","previous_headings":"","what":"Overview of Dataset Classes","title":"Representing fMRI Data in fmrireg","text":"fmrireg offers different dataset classes depending data stored: fmri_mem_dataset: volumetric fMRI data already loaded R memory (NeuroVec objects). fmri_file_dataset: volumetric fMRI data stored image files (e.g., NIfTI) disk. matrix_dataset: fMRI data represented standard R matrix (time points x voxels/components). latent_dataset: dimension-reduced data (e.g., PCA/ICA components), typically requiring fmristore package. inherit base fmri_dataset class.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_10_dataset.html","id":"in-memory-volumetric-data-fmri_mem_dataset","dir":"Articles","previous_headings":"","what":"In-Memory Volumetric Data (fmri_mem_dataset)","title":"Representing fMRI Data in fmrireg","text":"Use fMRI runs loaded neuroim2::NeuroVec objects R session. Key Arguments: scans: list NeuroVec objects, one run. mask: neuroim2::NeuroVol neuroim2::LogicalNeuroVol object representing brain mask. TR: Repetition time (seconds). run_length (Optional): Vector run lengths; omitted, inferred dimensions NeuroVec objects scans. event_table (Optional): data.frame containing experimental design information.","code":"# Create minimal example data (2 runs) d <- c(5, 5, 5, 20) # Small dimensions for example mask_vol <- neuroim2::LogicalNeuroVol(array(TRUE, d[1:3]), neuroim2::NeuroSpace(d[1:3]))  scan1 <- neuroim2::NeuroVec(array(rnorm(prod(d)), d), neuroim2::NeuroSpace(d)) scan2 <- neuroim2::NeuroVec(array(rnorm(prod(d)), d), neuroim2::NeuroSpace(d))  # Example event table events_df <- data.frame(   onset = c(5, 15, 5, 15),    condition = factor(c(\"A\", \"B\", \"A\", \"B\")),   run = c(1, 1, 2, 2) )  # Create the dataset object mem_dset <- fmri_mem_dataset(scans = list(scan1, scan2),                               mask = mask_vol,                               TR = 2.0,                               # run_length automatically inferred as c(20, 20)                              event_table = events_df)  print(mem_dset) #>  #> === fMRI Dataset === #>  #> ** Dimensions: #>   - Timepoints: 40  #>   - Runs: 2   #>   - Objects: 2 pre-loaded NeuroVec object(s) #>   - Voxels in mask: (lazy) #>  #> ** Temporal Structure: #>   - TR: 2 seconds #>   - Run lengths: 20, 20  #>  #> ** Event Table: #>   - Rows: 4  #>   - Variables: onset, condition, run  #>   - First few events: #>   onset condition run #> 1     5         A   1 #> 2    15         B   1 #> 3     5         A   2 # Access components print(mem_dset$sampling_frame) #> Sampling Frame #> ============== #>  #> Structure: #>   2 blocks #>   Total scans: 40 #>  #> Timing: #>   TR: 2 s #>   Precision: 0.1 s #>  #> Duration: #>   Total time: 80.0 s"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_10_dataset.html","id":"file-based-volumetric-data-fmri_file_dataset","dir":"Articles","previous_headings":"","what":"File-Based Volumetric Data (fmri_file_dataset)","title":"Representing fMRI Data in fmrireg","text":"often practical option typical fMRI analyses data resides files. Key Arguments: scans: character vector file paths 4D fMRI image files (e.g., .nii.gz), one path per run. mask: character string giving file path 3D mask image file. TR: Repetition time (seconds). run_length: numeric vector specifying number volumes (time points) run file listed scans. event_table (Optional): data.frame experimental design info. base_path (Optional): path prepend relative file paths scans mask. preload (Optional, Default: FALSE): TRUE, load mask scan data memory immediately. FALSE (recommended large data), data read accessed. mode (Optional): Storage mode neuroim2 reading data (e.g., “normal”, “mmap”). Using preload=FALSE memory-efficient required data segments read needed (e.g., model fitting).","code":"# --- Create Dummy Files (for illustration only) --- # In a real analysis, these files would already exist. tmp_dir <- tempdir() mask_filename <- \"mask.nii.gz\" scan1_filename <- \"run1.nii.gz\" scan2_filename <- \"run2.nii.gz\"  mask_file_full_path <- file.path(tmp_dir, mask_filename) scan1_file_full_path <- file.path(tmp_dir, scan1_filename) scan2_file_full_path <- file.path(tmp_dir, scan2_filename)  # Create small dummy mask and scans using neuroim2 functionality d <- c(5, 5, 5) # Mask dimensions d_run1 <- c(d, 20) # Run 1 dimensions (time=20) d_run2 <- c(d, 25) # Run 2 dimensions (time=25)  mask_vol_dummy <- neuroim2::NeuroVol(array(1, d), neuroim2::NeuroSpace(d)) scan1_dummy <- neuroim2::NeuroVec(array(rnorm(prod(d_run1)), d_run1), neuroim2::NeuroSpace(d_run1)) scan2_dummy <- neuroim2::NeuroVec(array(rnorm(prod(d_run2)), d_run2), neuroim2::NeuroSpace(d_run2))  # Ensure dummy files are written using their full paths neuroim2::write_vol(mask_vol_dummy, mask_file_full_path) #> Found more than one class \"gzfile\" in cache; using the first, from namespace 'BiocGenerics' #> Also defined by 'neuroim2' neuroim2::write_vec(scan1_dummy, scan1_file_full_path) #> Found more than one class \"gzfile\" in cache; using the first, from namespace 'BiocGenerics' #> Also defined by 'neuroim2' neuroim2::write_vec(scan2_dummy, scan2_file_full_path) #> Found more than one class \"gzfile\" in cache; using the first, from namespace 'BiocGenerics' #> Also defined by 'neuroim2' # --- End Dummy File Creation ---  # Create the file-based dataset object # Pass only filenames to 'scans' and 'mask', and specify the directory in 'base_path' file_dset <- fmri_dataset(scans = c(scan1_filename, scan2_filename),                              mask = mask_filename,                              TR = 1.5,                              run_length = c(20, 25), # Must match time dim of files                             event_table = events_df,                              base_path = tmp_dir,    # Set base_path to the temp directory                             preload = FALSE) # Keep data on disk #> Found more than one class \"gzfile\" in cache; using the first, from namespace 'BiocGenerics' #> Also defined by 'neuroim2' #> Found more than one class \"gzfile\" in cache; using the first, from namespace 'BiocGenerics' #> Also defined by 'neuroim2' #> Found more than one class \"gzfile\" in cache; using the first, from namespace 'BiocGenerics' #> Also defined by 'neuroim2'  # This print statement should now work print(file_dset) #>  #> === fMRI Dataset === #>  #> ** Dimensions: #>   - Timepoints: 45  #>   - Runs: 2   #>   - Backend: nifti_backend  #>   - Data dimensions: 45 x ? (timepoints x voxels) #>   - Voxels in mask: (lazy) #>  #> ** Temporal Structure: #>   - TR: 1.5 seconds #>   - Run lengths: 20, 25  #>  #> ** Event Table: #>   - Rows: 4  #>   - Variables: onset, condition, run  #>   - First few events: #> # A tibble: 3 × 3 #>   onset condition   run #>   <dbl> <fct>     <dbl> #> 1     5 A             1 #> 2    15 B             1 #> 3     5 A             2  # Clean up dummy files (optional, commented out for vignette) # file.remove(mask_file_full_path, scan1_file_full_path, scan2_file_full_path)"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_10_dataset.html","id":"matrix-data-matrix_dataset","dir":"Articles","previous_headings":"","what":"Matrix Data (matrix_dataset)","title":"Representing fMRI Data in fmrireg","text":"Use fMRI data already represented 2D matrix rows time points columns voxels components (e.g., surface projection ROI averaging). Key Arguments: datamat: numeric matrix (time x features). TR: Repetition time (seconds). run_length: Vector specifying number rows (time points) belonging run. event_table (Optional): data.frame design info (must total number rows datamat). matrix_dataset, concept spatial mask implicit; columns provided datamat included.","code":"# Example matrix (100 time points, 50 features/voxels) # Two runs of 50 time points each time_points <- 100 features <- 50 run_len <- c(50, 50) example_matrix <- matrix(rnorm(time_points * features), time_points, features)  # Example event table for matrix data events_mat_df <- data.frame(   onset = c(seq(5, 45, by=10), seq(5, 45, by=10)),    condition = factor(rep(c(\"C\", \"D\"), 10)),   run = rep(1:2, each = 5) )  mat_dset <- matrix_dataset(datamat = example_matrix,                             TR = 2.5,                             run_length = run_len,                            event_table = events_mat_df)  print(mat_dset) #>  #> === fMRI Dataset === #>  #> ** Dimensions: #>   - Timepoints: 100  #>   - Runs: 2   #>   - Matrix: 100 x 50 (timepoints x voxels) #>   - Voxels in mask: (lazy) #>  #> ** Temporal Structure: #>   - TR: 2.5 seconds #>   - Run lengths: 50, 50  #>  #> ** Event Table: #>   - Rows: 20  #>   - Variables: onset, condition, run  #>   - First few events: #>   onset condition run #> 1     5         C   1 #> 2    15         D   1 #> 3    25         C   1 print(mat_dset$sampling_frame) #> Sampling Frame #> ============== #>  #> Structure: #>   2 blocks #>   Total scans: 100 #>  #> Timing: #>   TR: 2.5 s #>   Precision: 0.1 s #>  #> Duration: #>   Total time: 250.0 s"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_10_dataset.html","id":"latent-data-latent_dataset","dir":"Articles","previous_headings":"","what":"Latent Data (latent_dataset)","title":"Representing fMRI Data in fmrireg","text":"class designed data undergone dimensionality reduction (e.g., PCA, ICA). wraps LatentNeuroVec object, stores basis vectors (latent components time) loadings (spatial maps components). Creating using LatentNeuroVec objects typically requires fmristore package. Key Arguments: lvec: LatentNeuroVec object fmristore package. TR: Repetition time (seconds). run_length: Vector specifying run lengths (must sum time dimension lvec). event_table (Optional): Experimental design data.frame. dataset type essentially behaves like matrix_dataset matrix columns latent component time series.","code":"# Conceptual example (requires fmristore package and a LatentNeuroVec) # Assuming 'my_latent_neuro_vec' is a LatentNeuroVec object representing # 20 components over 300 time points (2 runs of 150)  # latent_dset <- latent_dataset(lvec = my_latent_neuro_vec,  #                              TR = 2.0,  #                              run_length = c(150, 150), #                              event_table = some_event_df) #  # print(latent_dset)"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/a_10_dataset.html","id":"using-dataset-objects","dir":"Articles","previous_headings":"","what":"Using Dataset Objects","title":"Representing fMRI Data in fmrireg","text":"created, dataset objects serve primary data input fmrireg’s modeling functions: event_model(..., sampling_frame = dset$sampling_frame) baseline_model(..., sframe = dset$sampling_frame) fmri_lm(model, dataset = dset) estimate_betas(..., dataset = dset) provide standardized way access data (get_data(dset)), masks (get_mask(dset)), timing information (blocklens(dset), blockids(dset)), regardless underlying storage format. Choosing appropriate dataset class depends data resides (memory, files) format (volumetric, matrix, latent).","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/benchmark_datasets.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Using fMRI Benchmark Datasets","text":"fmrireg package includes comprehensive set benchmark datasets designed testing evaluating HRF fitting, beta estimation, fMRI analysis methods. datasets provide known ground truth various challenging scenarios commonly encountered fMRI analysis. vignette demonstrates use benchmark datasets evaluate analysis methods.","code":"library(fmrireg) #> Warning: replacing previous import 'fmridesign::blockids' by #> 'fmrihrf::blockids' when loading 'fmrireg' #>  #> Attaching package: 'fmrireg' #> The following object is masked from 'package:stats': #>  #>     convolve library(ggplot2) library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/benchmark_datasets.html","id":"available-benchmark-datasets","dir":"Articles","previous_headings":"","what":"Available Benchmark Datasets","title":"Using fMRI Benchmark Datasets","text":"Let’s start exploring benchmark datasets available:","code":"# List all available datasets datasets_info <- list_benchmark_datasets() print(datasets_info) #>                                                         Dataset #> BM_Canonical_HighSNR                       BM_Canonical_HighSNR #> BM_Canonical_LowSNR                         BM_Canonical_LowSNR #> BM_HRF_Variability_AcrossVoxels BM_HRF_Variability_AcrossVoxels #> BM_Trial_Amplitude_Variability   BM_Trial_Amplitude_Variability #> BM_Complex_Realistic                       BM_Complex_Realistic #>                                                                                                                        Description #> BM_Canonical_HighSNR                                 Canonical HRF (SPMG1), high SNR, 3 conditions, fixed amplitudes per condition #> BM_Canonical_LowSNR                                   Canonical HRF (SPMG1), low SNR, 3 conditions, fixed amplitudes per condition #> BM_HRF_Variability_AcrossVoxels                                         HRF varies across voxel groups, 2 conditions, moderate SNR #> BM_Trial_Amplitude_Variability                              Single condition with significant trial-to-trial amplitude variability #> BM_Complex_Realistic            Complex realistic scenario: 3 HRF groups, 3 conditions, variable durations/amplitudes, AR(2) noise"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/benchmark_datasets.html","id":"loading-and-exploring-a-dataset","dir":"Articles","previous_headings":"","what":"Loading and Exploring a Dataset","title":"Using fMRI Benchmark Datasets","text":"Let’s load high SNR canonical dataset explore structure:","code":"# Load the high SNR dataset data <- load_benchmark_dataset(\"BM_Canonical_HighSNR\")  # Get a summary of the dataset summary_info <- get_benchmark_summary(\"BM_Canonical_HighSNR\") print(summary_info$dimensions) #> $n_timepoints #> [1] 150 #>  #> $n_voxels #> [1] 100 #>  #> $n_events #> [1] 45 #>  #> $n_conditions #> [1] 3 print(summary_info$experimental_design) #> $conditions #> [1] \"Cond1\" \"Cond2\" \"Cond3\" #>  #> $events_per_condition #> $events_per_condition$Cond1 #> [1] 15 #>  #> $events_per_condition$Cond2 #> [1] 15 #>  #> $events_per_condition$Cond3 #> [1] 15 #>  #>  #> $TR #> [1] 2 #>  #> $total_time #> [1] 300 #>  #> $target_snr #> [1] 4"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/benchmark_datasets.html","id":"examining-the-data-structure","dir":"Articles","previous_headings":"","what":"Examining the Data Structure","title":"Using fMRI Benchmark Datasets","text":"benchmark dataset list. Key components include: description: text summary. Y_noisy: matrix noisy BOLD time series (time points x voxels). Y_clean: (available) BOLD signal without noise. event_onsets: Vector event start times. condition_labels: Vector condition names event. event_durations: Vector event durations. true_betas_condition: Ground truth beta values condition. true_hrf_parameters: Information HRF used simulation. TR, total_time, run_length: Scan parameters.","code":"# Look at the BOLD time series dimensions and event structure cat(\"Y_noisy BOLD data dimensions:\", dim(data$Y_noisy), \"\\n\") #> Y_noisy BOLD data dimensions: 150 100 cat(\"Number of events:\", length(data$event_onsets), \"\\n\") #> Number of events: 45 cat(\"Conditions:\", unique(data$condition_labels), \"\\n\") #> Conditions: Cond1 Cond2 Cond3 cat(\"Events per condition:\", table(data$condition_labels), \"\\n\") #> Events per condition: 15 15 15 cat(\"TR:\", data$TR, \"\\n\") #> TR: 2 cat(\"Run length:\", data$run_length, \"\\n\") #> Run length:"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/benchmark_datasets.html","id":"visualizing-the-data","dir":"Articles","previous_headings":"","what":"Visualizing the Data","title":"Using fMRI Benchmark Datasets","text":"Let’s visualize aspects benchmark dataset:","code":"# Plot the first few voxels' time series n_timepoints <- nrow(data$Y_noisy) time_points <- seq(0, by = data$TR, length.out = n_timepoints)  # Create a data frame for plotting plot_data <- data.frame(   Time = rep(time_points, 3),   BOLD = c(data$Y_noisy[, 1], data$Y_noisy[, 2], data$Y_noisy[, 3]),   Voxel = rep(paste(\"Voxel\", 1:3), each = n_timepoints) )  # Add event markers event_data <- data.frame(   Time = data$event_onsets,   Condition = data$condition_labels )  ggplot(plot_data, aes(x = Time, y = BOLD)) +   geom_line() +   geom_vline(data = event_data, aes(xintercept = Time, color = Condition),               alpha = 0.7, linetype = \"dashed\") +   facet_wrap(~Voxel, scales = \"free_y\") +   labs(title = \"BOLD Time Series with Event Markers\",        x = \"Time (seconds)\", y = \"BOLD Signal\") +   theme_minimal()"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/benchmark_datasets.html","id":"creating-design-matrices","dir":"Articles","previous_headings":"","what":"Creating Design Matrices","title":"Using fMRI Benchmark Datasets","text":"One key features ability create design matrices different HRF assumptions:","code":"# Create design matrix with the true HRF (canonical) X_true <- create_design_matrix_from_benchmark(\"BM_Canonical_HighSNR\", fmrihrf::HRF_SPMG1)  # Create design matrix with a different HRF (e.g., a Gaussian HRF instead of canonical) X_wrong <- create_design_matrix_from_benchmark(\"BM_Canonical_HighSNR\", fmrihrf::HRF_GAUSSIAN)  cat(\"True HRF design matrix dimensions:\", dim(X_true), \"\\n\") #> True HRF design matrix dimensions: 150 4 cat(\"Alternative HRF design matrix dimensions:\", dim(X_wrong), \"\\n\") #> Alternative HRF design matrix dimensions: 150 4"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/benchmark_datasets.html","id":"method-evaluation-example","dir":"Articles","previous_headings":"","what":"Method Evaluation Example","title":"Using fMRI Benchmark Datasets","text":"Let’s demonstrate evaluate simple method (OLS) benchmark dataset:","code":"# Fit ordinary least squares with the correct HRF betas_correct <- solve(t(X_true) %*% X_true) %*% t(X_true) %*% data$Y_noisy  # Fit OLS with the wrong HRF assumption betas_wrong <- solve(t(X_wrong) %*% X_wrong) %*% t(X_wrong) %*% data$Y_noisy  # Evaluate performance (remove intercept for comparison) performance_correct <- evaluate_method_performance(\"BM_Canonical_HighSNR\",                                                     betas_correct[-1, ],                                                     \"OLS_Correct_HRF\")  performance_wrong <- evaluate_method_performance(\"BM_Canonical_HighSNR\",                                                   betas_wrong[-1, ],                                                   \"OLS_Wrong_HRF\")  # Compare results cat(\"Correct HRF - Overall correlation:\", round(performance_correct$overall_metrics$correlation, 3), \"\\n\") #> Correct HRF - Overall correlation: 0.989 cat(\"Wrong HRF - Overall correlation:\", round(performance_wrong$overall_metrics$correlation, 3), \"\\n\") #> Wrong HRF - Overall correlation: 0.99  cat(\"Correct HRF - RMSE:\", round(performance_correct$overall_metrics$rmse, 3), \"\\n\") #> Correct HRF - RMSE: 0.044 cat(\"Wrong HRF - RMSE:\", round(performance_wrong$overall_metrics$rmse, 3), \"\\n\") #> Wrong HRF - RMSE: 8.415"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/benchmark_datasets.html","id":"comparing-true-vs-estimated-betas","dir":"Articles","previous_headings":"","what":"Comparing True vs Estimated Betas","title":"Using fMRI Benchmark Datasets","text":"","code":"# Get true betas true_betas <- data$true_betas_condition  # Create comparison plots comparison_data <- data.frame(   True = as.vector(true_betas),   Estimated_Correct = as.vector(betas_correct[-1, ]),   Estimated_Wrong = as.vector(betas_wrong[-1, ]),   Condition = rep(paste(\"Condition\", 1:3), each = ncol(true_betas)) )  # Plot true vs estimated (correct HRF) p1 <- ggplot(comparison_data, aes(x = True, y = Estimated_Correct, color = Condition)) +   geom_point(alpha = 0.6) +   geom_abline(slope = 1, intercept = 0, linetype = \"dashed\") +   labs(title = \"Correct HRF\", x = \"True Beta\", y = \"Estimated Beta\") +   theme_minimal()  # Plot true vs estimated (wrong HRF) p2 <- ggplot(comparison_data, aes(x = True, y = Estimated_Wrong, color = Condition)) +   geom_point(alpha = 0.6) +   geom_abline(slope = 1, intercept = 0, linetype = \"dashed\") +   labs(title = \"Wrong HRF\", x = \"True Beta\", y = \"Estimated Beta\") +   theme_minimal()  # Display plots side by side gridExtra::grid.arrange(p1, p2, ncol = 2)"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/benchmark_datasets.html","id":"testing-different-datasets","dir":"Articles","previous_headings":"","what":"Testing Different Datasets","title":"Using fMRI Benchmark Datasets","text":"Let’s compare performance across different benchmark scenarios:","code":"# Test on different datasets datasets_to_test <- c(\"BM_Canonical_HighSNR\", \"BM_Canonical_LowSNR\") results <- list()  for (dataset_name in datasets_to_test) {   # Load dataset and create design matrix   X <- create_design_matrix_from_benchmark(dataset_name, fmrihrf::HRF_SPMG1)   data_test <- load_benchmark_dataset(dataset_name)      # Fit model   betas <- solve(t(X) %*% X) %*% t(X) %*% data_test$Y_noisy      # Evaluate performance   perf <- evaluate_method_performance(dataset_name, betas[-1, ], \"OLS\")      results[[dataset_name]] <- list(     correlation = perf$overall_metrics$correlation,     rmse = perf$overall_metrics$rmse,     target_snr = data_test$target_snr   ) }  # Display results results_df <- data.frame(   Dataset = names(results),   Correlation = sapply(results, function(x) round(x$correlation, 3)),   RMSE = sapply(results, function(x) round(x$rmse, 3)),   Target_SNR = sapply(results, function(x) x$target_snr) )  print(results_df) #>                                   Dataset Correlation  RMSE Target_SNR #> BM_Canonical_HighSNR BM_Canonical_HighSNR       0.989 0.044        4.0 #> BM_Canonical_LowSNR   BM_Canonical_LowSNR       0.595 0.410        0.5"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/benchmark_datasets.html","id":"hrf-variability-dataset","dir":"Articles","previous_headings":"","what":"HRF Variability Dataset","title":"Using fMRI Benchmark Datasets","text":"Let’s explore dataset HRF variability across voxels:","code":"# Load the HRF variability dataset hrf_data <- load_benchmark_dataset(\"BM_HRF_Variability_AcrossVoxels\")  # Examine the HRF group assignments cat(\"HRF group assignments:\", table(hrf_data$true_hrf_group_assignment), \"\\n\") #> HRF group assignments: 50 50  # Note: The actual HRF objects used vary by voxel # The benchmark dataset contains voxels with different HRF shapes to test # methods that can handle HRF variability across the brain"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/benchmark_datasets.html","id":"trial-amplitude-variability","dir":"Articles","previous_headings":"","what":"Trial Amplitude Variability","title":"Using fMRI Benchmark Datasets","text":"Let’s examine trial--trial variability dataset:","code":"# Load the trial variability dataset trial_data <- load_benchmark_dataset(\"BM_Trial_Amplitude_Variability\")  # Look at the trial-wise amplitudes true_trial_amps <- trial_data$true_amplitudes_trial  # Plot amplitude variability across trials for first few voxels amp_plot_data <- data.frame(   Trial = rep(1:nrow(true_trial_amps), 3),   Amplitude = c(true_trial_amps[, 1], true_trial_amps[, 2], true_trial_amps[, 3]),   Voxel = rep(paste(\"Voxel\", 1:3), each = nrow(true_trial_amps)) )  ggplot(amp_plot_data, aes(x = Trial, y = Amplitude)) +   geom_line() +   geom_point() +   facet_wrap(~Voxel) +   labs(title = \"Trial-to-Trial Amplitude Variability\",        x = \"Trial Number\", y = \"True Amplitude\") +   theme_minimal()"},{"path":"https://bbuchsbaum.github.io/fmrireg/articles/benchmark_datasets.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Using fMRI Benchmark Datasets","text":"fMRI benchmark datasets provide comprehensive testing framework : Basic validation: Use BM_Canonical_HighSNR initial method testing Noise robustness: Compare performance high low SNR datasets HRF estimation: Test methods BM_HRF_Variability_AcrossVoxels Single-trial analysis: Evaluate LSS methods BM_Trial_Amplitude_Variability Complex scenarios: Challenge methods BM_Complex_Realistic Key advantages: Known ground truth: parameters precisely controlled recorded Realistic noise models: AR(1) AR(2) noise physiologically plausible parameters Comprehensive evaluation: Built-performance metrics comparison tools Reproducible: Fixed random seeds ensure consistent results Extensible: Framework allows easy addition new benchmark scenarios datasets enable rigorous, standardized evaluation fMRI analysis methods facilitate fair comparisons different approaches.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Bradley Buchsbaum. Author, maintainer.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Buchsbaum B (2025). fmrireg: R package anlysis fmri data. R package version 0.1.0, https://bbuchsbaum.github.io/fmrireg/.","code":"@Manual{,   title = {fmrireg: R package for the anlysis of fmri data},   author = {Bradley Buchsbaum},   year = {2025},   note = {R package version 0.1.0},   url = {https://bbuchsbaum.github.io/fmrireg/}, }"},{"path":"https://bbuchsbaum.github.io/fmrireg/index.html","id":null,"dir":"","previous_headings":"","what":"fmrireg • fMRI Analysis in R","title":"fmrireg • fMRI Analysis in R","text":"","code":"## Quick Start  ```r library(fmrireg)  # Load a benchmark dataset bm <- load_benchmark_dataset(\"BM_Canonical_HighSNR\")  # Create an event model events <- bm$core_data$event_table sframe <- sampling_frame(blocklens = bm$core_data$run_length, TR = bm$core_data$TR) emod <- event_model(onset ~ hrf(condition), data = events,                    block = ~run, sampling_frame = sframe)  # Fit the model fit <- fmri_lm(emod, dataset = bm$core_data)"},{"path":"https://bbuchsbaum.github.io/fmrireg/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"fmrireg • fMRI Analysis in R","text":"See comprehensive examples tutorials vignettes: Hemodynamic Response Functions Building Regressors Event Models Statistical Contrasts Linear Modeling","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/index.html","id":"performance-configuration","dir":"","previous_headings":"","what":"Performance Configuration","title":"fmrireg • fMRI Analysis in R","text":"internal C++ routines use RcppParallel. can control number threads setting R option fmrireg.num_threads environment variable FMRIREG_NUM_THREADS loading package. either set, fmrireg calls RcppParallel::setThreadOptions() loads.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/index.html","id":"development-status","dir":"","previous_headings":"","what":"Development Status","title":"fmrireg • fMRI Analysis in R","text":"fmrireg currently active development. core functionality stable, API may change continue improve package. Please file issues bugs feature requests.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"fmrireg • fMRI Analysis in R","text":"use fmrireg research, please cite:","code":"Buchsbaum, B. R. (2024). fmrireg: fMRI Analysis in R. R package version 0.1.0. https://github.com/bbuchsbaum/fmrireg"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/Fcontrasts.html","id":null,"dir":"Reference","previous_headings":"","what":"Return the global onsets of an object — Fcontrasts","title":"Return the global onsets of an object — Fcontrasts","text":"Convert relative onset times global (cumulative) onset times across runs. Global onsets defined cumulative time runs, meaning reset zero run. useful : Converting run-specific onsets experiment-wide timings Aligning events across multiple runs Computing temporal distances events different runs Split dataset manageable chunks processing. particularly useful parallel processing large fMRI datasets. Chunks can created either run (runwise=TRUE) dividing data specified number pieces. chunk contains subset data metadata position full dataset. Extract onset times events model object. Onsets represent timing experimental events fMRI design, typically seconds start run. times used : Create regressors convolving HRF Verify event timing design Analyze temporal patterns events Extract duration events model object. Durations represent long event lasts fMRI design, typically seconds. important : Modeling block designs stimuli non-zero duration Creating accurate HRF convolutions extended events Distinguishing brief sustained neural activity Get sampling times regressor sampling frame. times represent fMRI data acquired can either relative (within run) global (cumulative across runs). Sampling times used : Evaluate regressors scan acquisition times Align model predictions data collection Convert TR-based time-based representations Split vector matrix values separate pieces based block/run IDs. function useful : Separating data individual runs Processing blocks independently Analyzing run-specific patterns Get block run number associated scan/timepoint dataset. Block indices used : Track scans belong runs Split data experimental blocks Align events corresponding runs Apply run-specific processing Get number scans timepoints block/run dataset. Block lengths used : Define temporal structure experiment specifying scan counts timing per run Allocate memory data matrices pre-allocating arrays based scan counts Validate data dimensions across runs checking expected lengths Calculate global timing information computing cumulative timing across runs Create F-contrasts test overall effects model terms. F-contrasts used : categorical Test effect categorical predictor basis Compare multiple basis functions simultaneously nonlinear Test nonlinear effects continuous predictors overall Evaluate overall significance model terms","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/Fcontrasts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return the global onsets of an object — Fcontrasts","text":"","code":"Fcontrasts(x, ...)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/Fcontrasts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return the global onsets of an object — Fcontrasts","text":"x model term generate contrasts (typically event_term event_model) ... Additional arguments passed methods. Common arguments include: basis Character; type basis functions used nbasis Integer; number basis functions exclude Character vector conditions exclude onsets numeric vector relative onset times within run/block nchunks Integer; number chunks create (ignored runwise=TRUE) blockids Numeric vector specifying blocks/runs include (optional) global Logical; TRUE, return cumulative times across runs (default: FALSE)","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/Fcontrasts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return the global onsets of an object — Fcontrasts","text":"numeric vector global onset times : onset adjusted cumulative duration previous runs Times units input onsets (typically seconds) NA returned onsets exceed block duration iterator object yields data chunks, chunk contains: data Matrix data values chunk chunk_num Index chunk voxel_ind Indices voxels chunk row_ind Indices timepoints chunk numeric vector onset times seconds, : value represents start time event Times relative start run Order matches original event sequence numeric vector durations seconds, : value represents long event lasts Zero values indicate instantaneous events Order matches corresponding event sequence numeric vector sampling times seconds, : value represents scan acquisition time Times account TR (repetition time) spacing global=FALSE, times reset start run global=TRUE, times accumulate across runs list element contains data one block: List length equals number blocks element contains values one block Order matches original block sequence numeric vector : element block/run ID scan IDs sequential integers starting 1 Length matches total number scans numeric vector : element number scans block run Length equals number blocks/runs Values positive integers list contrast specifications contains: weights Matrix contrast weights term model term tested name Descriptive name contrast df Degrees freedom contrast","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/Fcontrasts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Return the global onsets of an object — Fcontrasts","text":"","code":"# Create a sampling frame with three runs sframe <- sampling_frame(   blocklens = c(100, 100, 100),  # 100 scans per run   TR = 2                         # 2 seconds per scan )  # Define events in each run run_onsets <- c(10, 20, 30)     # Events at 10s, 20s, 30s run_ids <- c(1, 2, 3)           # One event per run  # Convert to global onsets global_times <- global_onsets(   sframe,   onsets = run_onsets,   blockids = run_ids ) # Returns: c(10, 220, 430) # Because: #  - Run 1: 10s #  - Run 2: 20s + (100 scans * 2s) = 220s #  - Run 3: 30s + (200 scans * 2s) = 430s # Create a simple matrix dataset X <- matrix(rnorm(100 * 1000), 100, 1000)  # 100 timepoints, 1000 voxels dset <- fmridataset::matrix_dataset(   X,    TR = 2,   run_length = c(50, 50)  # Two runs of 50 timepoints each )  # Create chunks by run run_chunks <- fmridataset::data_chunks(dset, runwise = TRUE)  # Process each run chunk foreach::foreach(chunk = run_chunks) %do% {   # chunk$data contains the data for one run   # chunk$row_ind shows which timepoints are included   mean_signal <- colMeans(chunk$data) } #> Error in foreach::foreach(chunk = run_chunks) %do% {    mean_signal <- colMeans(chunk$data)}: could not find function \"%do%\"  # Create arbitrary number of chunks vox_chunks <- fmridataset::data_chunks(dset, nchunks = 4)  # Process chunks in parallel foreach::foreach(chunk = vox_chunks) %dopar% {   # chunk$data contains subset of voxels   # chunk$voxel_ind shows which voxels are included   apply(chunk$data, 2, sd) } #> Error in foreach::foreach(chunk = vox_chunks) %dopar% {    apply(chunk$data, 2, sd)}: could not find function \"%dopar%\" # Create event data with multiple conditions event_data <- data.frame(   condition = factor(c(\"face\", \"house\", \"face\", \"house\")),   onsets = c(1, 10, 20, 30),   run = c(1, 1, 1, 1) )  # Create sampling frame sframe <- sampling_frame(blocklens = 50, TR = 2)  # Create event term eterm <- event_term(   list(condition = event_data$condition),   onsets = event_data$onsets,   blockids = event_data$run )  # Get onsets from term onset_times <- onsets(eterm)  # Returns: c(1, 10, 20, 30)  # Create and get onsets from event model evmodel <- event_model(   onsets ~ hrf(condition),   data = event_data,   block = ~run,   sampling_frame = sframe )  model_onsets <- onsets(evmodel) #> Error in UseMethod(\"onsets\"): no applicable method for 'onsets' applied to an object of class \"c('event_model', 'list')\" # Create event data with varying durations event_data <- data.frame(   condition = factor(c(\"block\", \"event\", \"block\", \"event\")),   onsets = c(1, 10, 20, 30),   durations = c(8, 0, 8, 0),  # 8s blocks and instantaneous events   run = c(1, 1, 1, 1) )  # Create event term eterm <- event_term(   list(condition = event_data$condition),   onsets = event_data$onsets,   durations = event_data$durations,   blockids = event_data$run )  # Get durations from term dur <- durations(eterm)  # Returns: c(8, 0, 8, 0) #> Error in UseMethod(\"durations\"): no applicable method for 'durations' applied to an object of class \"c('event_term', 'event_seq')\" # Create a sampling frame with multiple runs sframe <- sampling_frame(   blocklens = c(100, 100, 100),  # 100 scans per run   TR = 2,                        # 2 seconds per scan   start_time = 0                 # Start at time 0 )  # Get relative sampling times (reset each run) rel_times <- samples(sframe) # First few times: 0, 2, 4, 6, ... (resets each run)  # Get global sampling times (cumulative) glob_times <- samples(sframe, global = TRUE) # Shows: 0, 2, 4, ..., 198, 200, 202, ..., 598  # Get times for specific runs run2_times <- samples(sframe, blockids = 2) # Times for second run only  # Create regressor and get its sampling times event_data <- data.frame(   onsets = c(1, 10, 20),   run = c(1, 1, 1) ) reg <- regressor(   onsets = event_data$onsets,   sampling_frame = sframe ) #> Error in regressor(onsets = event_data$onsets, sampling_frame = sframe): unused argument (sampling_frame = sframe) reg_times <- samples(reg) #> Error: object 'reg' not found # Create a sampling frame with multiple runs sframe <- sampling_frame(   blocklens = c(50, 50, 50),  # 3 runs of 50 scans each   TR = 2 )  # Create some example data data_values <- rnorm(150)  # 150 values (50 per run)  # Split data by run run_data <- split_by_block(sframe, data_values) #> Error in UseMethod(\"split_by_block\"): no applicable method for 'split_by_block' applied to an object of class \"sampling_frame\" # Returns list with 3 elements, each containing 50 values  # Create matrix dataset X <- matrix(rnorm(150 * 10), 150, 10)  # 150 timepoints, 10 voxels dset <- fmridataset::matrix_dataset(   X,   TR = 2,   run_length = c(50, 50, 50) )  # Split matrix data by run run_matrices <- split_by_block(dset) #> Error in UseMethod(\"split_by_block\"): no applicable method for 'split_by_block' applied to an object of class \"c('matrix_dataset', 'fmri_dataset', 'list')\" # Returns list with 3 matrices, each 50 x 10 # Create a sampling frame with multiple runs sframe <- sampling_frame(   blocklens = c(50, 75, 50),  # Different length runs   TR = 2 )  # Get block IDs for all scans block_ids <- blockids(sframe) # Returns: c(1,1,...,1, 2,2,...,2, 3,3,...,3) # 50 ones, 75 twos, 50 threes  # Create a matrix dataset X <- matrix(rnorm(175 * 10), 175, 10)  # 175 timepoints (50+75+50), 10 voxels dset <- fmridataset::matrix_dataset(   X,   TR = 2,   run_length = c(50, 75, 50) )  # Note: blockids method for matrix_dataset is in the fmridataset package # To get block IDs from a dataset, ensure fmridataset is loaded # Create a sampling frame with varying run lengths sframe <- sampling_frame(   blocklens = c(100, 150, 100),  # Different length runs   TR = 2 )  # Get number of scans per run run_lengths <- blocklens(sframe)  # Returns: c(100, 150, 100)  # Use block lengths to create a dataset total_scans <- sum(run_lengths)  # 350 total timepoints X <- matrix(rnorm(total_scans * 10), total_scans, 10)  # 10 voxels dset <- fmridataset::matrix_dataset(   X,   TR = 2,   run_length = run_lengths )  # Verify block lengths in dataset dset_lengths <- blocklens(dset) #> Error in UseMethod(\"blocklens\"): no applicable method for 'blocklens' applied to an object of class \"c('matrix_dataset', 'fmri_dataset', 'list')\"  # Use lengths to create time vectors for each run time_vectors <- lapply(run_lengths, function(len) seq(0, by = 2, length.out = len)) # Create event data with multiple conditions event_data <- data.frame(   condition = factor(c(\"A\", \"B\", \"C\", \"A\", \"B\", \"C\")),   rt = c(0.8, 1.2, 0.9, 1.1, 0.7, 1.3),   onsets = c(1, 10, 20, 30, 40, 50),   run = c(1, 1, 1, 1, 1, 1) )  # Create sampling frame sframe <- sampling_frame(blocklens = 60, TR = 2)  # Create event model with multiple terms evmodel <- event_model(   onsets ~ hrf(condition) + hrf(rt),   data = event_data,   block = ~run,   sampling_frame = sframe )  # Get F-contrast for main effect of condition cond_contrast <- Fcontrasts(evmodel) #> Error in UseMethod(\"Fcontrasts\"): no applicable method for 'Fcontrasts' applied to an object of class \"c('event_model', 'list')\"  # Create model with multiple basis functions evmodel2 <- event_model(   onsets ~ hrf(condition, basis = \"fourier\", nbasis = 3),   data = event_data,   block = ~run,   sampling_frame = sframe )  # Get F-contrasts testing all basis functions basis_contrasts <- Fcontrasts(evmodel2) #> Error in UseMethod(\"Fcontrasts\"): no applicable method for 'Fcontrasts' applied to an object of class \"c('event_model', 'list')\""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/ar_parameters.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Estimated AR Parameters from fmri_lm Fit — ar_parameters","title":"Extract Estimated AR Parameters from fmri_lm Fit — ar_parameters","text":"Retrieves estimated autoregressive parameters fitted fMRI linear model used AR error modeling.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/ar_parameters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Estimated AR Parameters from fmri_lm Fit — ar_parameters","text":"","code":"ar_parameters(object, ...)  # S3 method for class 'fmri_lm' ar_parameters(object, ...)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/ar_parameters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Estimated AR Parameters from fmri_lm Fit — ar_parameters","text":"object object class fmri_lm ... Additional arguments (currently unused)","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/ar_parameters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Estimated AR Parameters from fmri_lm Fit — ar_parameters","text":"numeric vector AR coefficients AR modeling used, NULL AR modeling performed (cor_struct = \"iid\"). runwise estimation without global AR, returns average run-specific estimates.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/ar_parameters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Estimated AR Parameters from fmri_lm Fit — ar_parameters","text":"","code":"if (FALSE) { # \\dontrun{ # Fit model with AR(1) errors fit <- fmri_lm(onset ~ hrf(cond), dataset = dset, cor_struct = \"ar1\") ar_parameters(fit)  # Extract estimated AR(1) coefficient } # }"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/ar_whiten_inplace.html","id":null,"dir":"Reference","previous_headings":"","what":"AR(p) whitening of data and design matrices — ar_whiten_inplace","title":"AR(p) whitening of data and design matrices — ar_whiten_inplace","text":"Applies causal AR filter defined phi_coeffs Y X matrices place. filter equation :","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/ar_whiten_inplace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"AR(p) whitening of data and design matrices — ar_whiten_inplace","text":"","code":"ar_whiten_inplace(Y, X, phi_coeffs, exact_first_ar1 = FALSE, parallel = TRUE)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/ar_whiten_inplace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"AR(p) whitening of data and design matrices — ar_whiten_inplace","text":"Y Numeric matrix data (time x voxels) X Numeric matrix design (time x predictors) phi_coeffs Numeric vector AR coefficients (length p) exact_first_ar1 Logical, apply exact variance-normalizing scaling first sample AR(1). p > 1, scaling applied. parallel Logical, enable OpenMP parallelization across columns","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/ar_whiten_inplace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"AR(p) whitening of data and design matrices — ar_whiten_inplace","text":"List components 'Y' 'X' containing whitened matrices","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/ar_whiten_inplace.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"AR(p) whitening of data and design matrices — ar_whiten_inplace","text":"v_t = y_t - sum(phi_k * y_t-k, k=1 p) function assumes valid (stationary) AR coefficients provided. checks stationarity performed. exact_first_ar1 = TRUE p = 1, first residual multiplied sqrt(1 - phi^2) proper variance normalization. scaling applied AR(1) models.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/ar_whiten_void.html","id":null,"dir":"Reference","previous_headings":"","what":"AR(p) whitening with void return (no-copy version) — ar_whiten_void","title":"AR(p) whitening with void return (no-copy version) — ar_whiten_void","text":"efficient version modifies matrices place without returning copies. Use need return values.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/ar_whiten_void.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"AR(p) whitening with void return (no-copy version) — ar_whiten_void","text":"","code":"ar_whiten_void(Y, X, phi_coeffs, exact_first_ar1 = FALSE, parallel = TRUE)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/ar_whiten_void.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"AR(p) whitening with void return (no-copy version) — ar_whiten_void","text":"Y Numeric matrix data (time x voxels) - modified place X Numeric matrix design (time x predictors) - modified place phi_coeffs Numeric vector AR coefficients (length p) exact_first_ar1 Logical, apply exact scaling first sample AR(1) parallel Logical, enable OpenMP parallelization across columns","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/as.array.NeuroVec.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce NeuroVec to base array — as.array.NeuroVec","title":"Coerce NeuroVec to base array — as.array.NeuroVec","text":"method allows NeuroVec objects neuroim2 converted base R arrays using standard .array() function. particularly useful testing data manipulation contexts.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/as.array.NeuroVec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce NeuroVec to base array — as.array.NeuroVec","text":"","code":"# S3 method for class 'NeuroVec' as.array(x, ...)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/as.array.NeuroVec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce NeuroVec to base array — as.array.NeuroVec","text":"x NeuroVec object neuroim2 ... Additional arguments (currently unused)","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/as.array.NeuroVec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce NeuroVec to base array — as.array.NeuroVec","text":"base R array containing data NeuroVec object","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/autoplot.html","id":null,"dir":"Reference","previous_headings":"","what":"Autoplot method for Reg objects — autoplot.Reg","title":"Autoplot method for Reg objects — autoplot.Reg","text":"Creates ggplot visualization fMRI regressor object.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/autoplot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Autoplot method for Reg objects — autoplot.Reg","text":"","code":"# S3 method for class 'Reg' autoplot(object, grid = NULL, precision = 0.1, method = \"conv\", ...)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/autoplot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Autoplot method for Reg objects — autoplot.Reg","text":"object Reg object (one inheriting , like regressor). grid Optional numeric vector specifying time points (seconds) evaluation. NULL, default grid generated based object's onsets span. precision Numeric precision HRF evaluation grid needs generation internal evaluation requires (passed evaluate). method Evaluation method passed evaluate. ... Additional arguments (currently unused).","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/autoplot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Autoplot method for Reg objects — autoplot.Reg","text":"ggplot object.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/chunkwise_lm.fmri_dataset.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform Chunkwise Linear Modeling on fMRI Dataset — chunkwise_lm.fmri_dataset","title":"Perform Chunkwise Linear Modeling on fMRI Dataset — chunkwise_lm.fmri_dataset","text":"function performs chunkwise linear model analysis fMRI dataset, splitting dataset chunks running linear model chunk.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/chunkwise_lm.fmri_dataset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform Chunkwise Linear Modeling on fMRI Dataset — chunkwise_lm.fmri_dataset","text":"","code":"# S3 method for class 'fmri_dataset' chunkwise_lm(   dset,   model,   contrast_objects,   nchunks,   cfg,   verbose = FALSE,   use_fast_path = FALSE,   progress = FALSE,   phi_fixed = NULL,   sigma_fixed = NULL )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/chunkwise_lm.fmri_dataset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform Chunkwise Linear Modeling on fMRI Dataset — chunkwise_lm.fmri_dataset","text":"dset fmri_dataset object. model fmri_model used analysis. contrast_objects list full contrast objects. nchunks number chunks divide dataset . cfg fmri_lm_config object containing fitting options. verbose Logical. Whether display progress messages (default FALSE). use_fast_path Logical. TRUE, use matrix-based computation speed. Default FALSE. progress Logical. Display progress bar chunk processing. Default FALSE. phi_fixed Optional fixed AR parameters. sigma_fixed Optional fixed robust scale estimate.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/chunkwise_lm.fmri_dataset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform Chunkwise Linear Modeling on fMRI Dataset — chunkwise_lm.fmri_dataset","text":"list containing unpacked chunkwise results.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/chunkwise_lm.fmri_dataset_old.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform Chunkwise Linear Modeling on fMRI Dataset — chunkwise_lm.fmri_dataset_old","title":"Perform Chunkwise Linear Modeling on fMRI Dataset — chunkwise_lm.fmri_dataset_old","text":"function performs chunkwise linear model analysis fMRI dataset, splitting dataset chunks running linear model chunk.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/chunkwise_lm.fmri_dataset_old.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform Chunkwise Linear Modeling on fMRI Dataset — chunkwise_lm.fmri_dataset_old","text":"","code":"# S3 method for class 'fmri_dataset_old' chunkwise_lm(   dset,   model,   contrast_objects,   nchunks,   cfg,   verbose = FALSE,   use_fast_path = FALSE,   progress = FALSE,   phi_fixed = NULL,   sigma_fixed = NULL )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/chunkwise_lm.fmri_dataset_old.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform Chunkwise Linear Modeling on fMRI Dataset — chunkwise_lm.fmri_dataset_old","text":"dset fmri_dataset object. model fmri_model used analysis. contrast_objects list full contrast objects. nchunks number chunks divide dataset . cfg fmri_lm_config object containing fitting options. verbose Logical. Whether display progress messages (default FALSE). use_fast_path Logical. TRUE, use matrix-based computation speed. Default FALSE. progress Logical. Display progress bar chunk processing. Default FALSE. phi_fixed Optional fixed AR parameters. sigma_fixed Optional fixed robust scale estimate.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/chunkwise_lm.fmri_dataset_old.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform Chunkwise Linear Modeling on fMRI Dataset — chunkwise_lm.fmri_dataset_old","text":"list containing unpacked chunkwise results.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Column Names or Identifiers — columns","title":"Extract Column Names or Identifiers — columns","text":"Extract column names identifiers object. parametric basis objects, returns tokens representing type variables (categorical continuous).","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Column Names or Identifiers — columns","text":"","code":"columns(x)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Column Names or Identifiers — columns","text":"x object (typically ParametricBasis)","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Column Names or Identifiers — columns","text":"character vector column identifiers","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/conditions.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize the entire design matrix as a heatmap — conditions.convolved_term","title":"Visualize the entire design matrix as a heatmap — conditions.convolved_term","text":"Generate heatmap visualization design matrix, showing regressor values time. useful inspecting temporal structure fMRI design matrices.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/conditions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize the entire design matrix as a heatmap — conditions.convolved_term","text":"","code":"# S3 method for class 'convolved_term' conditions(x, ...)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/conditions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize the entire design matrix as a heatmap — conditions.convolved_term","text":"x model object (event_model, baseline_model, fmri_model) ... Additional arguments passed methods. Common arguments include: rescale_cols Logical; TRUE, columns rescaled (-1,1) block_separators Logical; TRUE, draw white lines blocks rotate_x_text Logical; TRUE, rotate x-axis labels 45 degrees","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/conditions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize the entire design matrix as a heatmap — conditions.convolved_term","text":"ggplot2 object containing design matrix heatmap","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/contrast_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a contrast set — contrast_set","title":"Create a contrast set — contrast_set","text":"Create contrast set","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/contrast_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a contrast set — contrast_set","text":"","code":"contrast_set(...)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/contrast_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a contrast set — contrast_set","text":"... contrast specifications","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/correlation_map.fmri_model.html","id":null,"dir":"Reference","previous_headings":"","what":"correlation_map.fmri_model — correlation_map.fmri_model","title":"correlation_map.fmri_model — correlation_map.fmri_model","text":"Generates correlation heatmap columns fmri_model's combined event+baseline design matrix.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/correlation_map.fmri_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"correlation_map.fmri_model — correlation_map.fmri_model","text":"","code":"# S3 method for class 'fmri_model' correlation_map(   x,   method = c(\"pearson\", \"spearman\"),   half_matrix = FALSE,   absolute_limits = TRUE,   ... )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/correlation_map.fmri_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"correlation_map.fmri_model — correlation_map.fmri_model","text":"x fmri_model. method Correlation method (e.g., \"pearson\", \"spearman\"). half_matrix Logical; TRUE, display lower triangle matrix. absolute_limits Logical; TRUE, set color scale limits -1 1. ... Additional arguments passed internal plotting functions.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/create_design_matrix_from_benchmark.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Design Matrix from Benchmark Dataset — create_design_matrix_from_benchmark","title":"Create Design Matrix from Benchmark Dataset — create_design_matrix_from_benchmark","text":"Helper function create design matrix benchmark dataset using specified HRF. useful testing different HRF assumptions ground truth.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/create_design_matrix_from_benchmark.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Design Matrix from Benchmark Dataset — create_design_matrix_from_benchmark","text":"","code":"create_design_matrix_from_benchmark(   dataset_name,   hrf,   include_intercept = TRUE )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/create_design_matrix_from_benchmark.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Design Matrix from Benchmark Dataset — create_design_matrix_from_benchmark","text":"dataset_name Character string specifying dataset use hrf HRF object use convolution (e.g., fmrihrf::HRF_SPMG1) include_intercept Logical, whether include intercept column","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/create_design_matrix_from_benchmark.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Design Matrix from Benchmark Dataset — create_design_matrix_from_benchmark","text":"matrix design matrix (time x conditions)","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/create_design_matrix_from_benchmark.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Design Matrix from Benchmark Dataset — create_design_matrix_from_benchmark","text":"","code":"# Create design matrix using canonical HRF X <- create_design_matrix_from_benchmark(\"BM_Canonical_HighSNR\", fmrihrf::HRF_SPMG1)  # Test with a different HRF X_wrong <- create_design_matrix_from_benchmark(\"BM_Canonical_HighSNR\", fmrihrf::HRF_SPMG2)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/create_fmri_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an fMRI Model — create_fmri_model","title":"Create an fMRI Model — create_fmri_model","text":"function creates fMRI model consisting event model baseline model. function creates fmri_model object formula, block specification, dataset. convenience function combines event baseline models. function creates fmri_model combining event model baseline model. baseline model provided, default one created based dataset.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/create_fmri_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an fMRI Model — create_fmri_model","text":"","code":"create_fmri_model(   formula,   block,   baseline_model = NULL,   dataset,   drop_empty = TRUE,   durations = 0 )  create_fmri_model(   formula,   block,   baseline_model = NULL,   dataset,   drop_empty = TRUE,   durations = 0 )  create_fmri_model(   formula,   block,   baseline_model = NULL,   dataset,   drop_empty = TRUE,   durations = 0 )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/create_fmri_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an fMRI Model — create_fmri_model","text":"formula model formula experimental events. block model formula block structure. baseline_model (Optional) baseline_model object. NULL, default baseline model created. dataset fmri_dataset containing event table sampling frame. drop_empty Logical. Whether remove factor levels zero size. Default TRUE. durations vector event durations. Default 0.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/create_fmri_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an fMRI Model — create_fmri_model","text":"fmri_model object. fmri_model object also stores dataset fmri_model object.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/create_fmri_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an fMRI Model — create_fmri_model","text":"","code":"if (FALSE) { # \\dontrun{ # Assuming you have an fmri_dataset object named ds and a formula for events: fmri_mod <- create_fmri_model(formula = onset ~ hrf(x) + hrf(y),                               block = ~ run,                               dataset = ds,                               drop_empty = TRUE,                               durations = rep(0, nrow(ds$event_table))) } # }"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/design_map.fmri_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Heatmap visualization of the combined fmri_model design matrix — design_map.fmri_model","title":"Heatmap visualization of the combined fmri_model design matrix — design_map.fmri_model","text":"Produces single heatmap columns design matrix fmri_model object, merges event_model baseline_model regressors. Rows scans; columns regressors. Optionally draws horizontal lines blocks (runs), rotates x‐axis labels diagonally readability.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/design_map.fmri_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Heatmap visualization of the combined fmri_model design matrix — design_map.fmri_model","text":"","code":"# S3 method for class 'fmri_model' design_map(   x,   block_separators = TRUE,   rotate_x_text = TRUE,   fill_midpoint = NULL,   fill_limits = NULL,   ... )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/design_map.fmri_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Heatmap visualization of the combined fmri_model design matrix — design_map.fmri_model","text":"x fmri_model object. block_separators Logical; TRUE, draw white horizontal lines blocks. rotate_x_text Logical; TRUE, rotate x-axis labels 45 degrees. fill_midpoint Numeric NULL; NULL, passed scale_fill_gradient2 center color scale (e.g. fill_midpoint=0). fill_limits Numeric vector length 2 NULL; passed fill scale limits= argument. can clip expand color range. ... Additional arguments passed geom_tile.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/design_map.fmri_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Heatmap visualization of the combined fmri_model design matrix — design_map.fmri_model","text":"ggplot2 plot object.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/design_matrix.fmri_lm.html","id":null,"dir":"Reference","previous_headings":"","what":"Design Matrix Method for fmri_lm Objects — design_matrix.fmri_lm","title":"Design Matrix Method for fmri_lm Objects — design_matrix.fmri_lm","text":"Extract design matrix fmri_lm object delegating model component.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/design_matrix.fmri_lm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Design Matrix Method for fmri_lm Objects — design_matrix.fmri_lm","text":"","code":"# S3 method for class 'fmri_lm' design_matrix(x, ...)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/design_matrix.fmri_lm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Design Matrix Method for fmri_lm Objects — design_matrix.fmri_lm","text":"x fmri_lm object ... Additional arguments passed design_matrix method model","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/design_matrix.fmri_lm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Design Matrix Method for fmri_lm Objects — design_matrix.fmri_lm","text":"design matrix fmri_lm object's model","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/design_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Get term indices from a model or term — correlation_map","title":"Get term indices from a model or term — correlation_map","text":"Get indices map model terms corresponding columns design matrix. indices essential : Extracting coefficients specific terms Computing contrasts specific model components Mapping event terms baseline terms Identifying design matrix columns belong terms Extract unique elements term variable natural order. categorical variables (factors), returns factor levels. continuous variables, returns unique values ascending order. event terms multiple variables, returns combined elements. Generate correlation heatmap showing relationships columns design matrix. visualization helps identify potential collinearity regressors model. event models, shows correlations different conditions. baseline models, shows correlations drift nuisance terms.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/design_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get term indices from a model or term — correlation_map","text":"","code":"correlation_map(x, ...)  # S3 method for class 'convolved_term' design_matrix(x, blockid = NULL, ...)  # S3 method for class 'fmri_model' design_matrix(x, blockid = NULL, ...)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/design_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get term indices from a model or term — correlation_map","text":"x model object (event_model, baseline_model, fmri_model) ... Additional arguments passed methods. Common arguments include: method Correlation method (\"pearson\" \"spearman\") half_matrix Logical; TRUE, show lower triangle absolute_limits Logical; TRUE, set color limits [-1,1] blockid Numeric vector specifying blocks/runs include (optional) allrows Logical; TRUE, return rows including events (default: FALSE) drop.empty Logical; TRUE, drop empty conditions (default: TRUE) Character; extract - \"unique\" unique values \"\" values (default: \"unique\") transformed Logical; TRUE, return transformed values (default: FALSE)","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/design_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get term indices from a model or term — correlation_map","text":"named list element contains column indices design matrix corresponding term. example: event terms: Indices experimental condition baseline terms: Indices drift block terms convolved terms: Indices basis function tibble containing design matrix, : Rows represent time points (scans) Columns represent predictor variables Column names indicate condition regressor (see Details) vector containing ordered elements: factors: factor levels defined order numeric variables: Unique values ascending order event terms: Combined elements variables ggplot2 object containing correlation heatmap, : Rows columns represent model terms Colors indicate correlation strength (-1 1) Darker colors indicate stronger correlations","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/design_matrix.html","id":"column-naming-post-refactor-","dir":"Reference","previous_headings":"","what":"Column Naming (Post-Refactor)","title":"Get term indices from a model or term — correlation_map","text":"version X.Y.Z, column names final design matrix generated event_model follow structure: term_tag + _ + condition_tag + _b## basis suffix Refer event_model documentation details term_tag condition_tag generation. design_matrix methods individual term types (like design_matrix.event_term) return unconvolved predictors whose names may yet follow final structure. final naming applied convolve.event_term assembled build_event_model_design_matrix.","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/design_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get term indices from a model or term — correlation_map","text":"","code":"# Create a model with multiple terms event_data <- data.frame(   stimulus = factor(c(\"face\", \"house\", \"face\", \"house\")),   rt = c(0.8, 1.2, 0.9, 1.1),   onsets = c(1, 10, 20, 30),   run = c(1, 1, 1, 1) )  # Create sampling frame sframe <- sampling_frame(blocklens = 50, TR = 2)  # Create event model with multiple terms evmodel <- event_model(   onsets ~ hrf(stimulus) + hrf(rt, basis = \"fourier\", nbasis = 2),   data = event_data,   block = ~run,   sampling_frame = sframe )  # Get indices for each term indices <- term_indices(evmodel) #> Error in UseMethod(\"term_indices\"): no applicable method for 'term_indices' applied to an object of class \"c('event_model', 'list')\" # Returns list with: #  - Indices for stimulus conditions #  - Indices for rt basis functions  # Create full model with baseline bmodel <- baseline_model(basis = \"bs\", degree = 3, sframe = sframe) fmodel <- fmri_model(evmodel, bmodel) #> Error in eval(assertion, env): argument \"dataset\" is missing, with no default  # Get indices for full model full_indices <- term_indices(fmodel) #> Error: object 'fmodel' not found # Returns indices for both event and baseline terms # Create event terms with different types  # Categorical variable event_data <- data.frame(   condition = factor(c(\"A\", \"B\", \"A\", \"B\"), levels = c(\"B\", \"A\")),   onsets = c(1, 10, 20, 30),   run = c(1, 1, 1, 1) ) cat_term <- event_term(   list(condition = event_data$condition),   onsets = event_data$onsets,   blockids = event_data$run ) elements(cat_term)  # Returns: c(\"B\", \"A\") #> $condition #>      condition #> [1,]         2 #> [2,]         1 #> [3,]         2 #> [4,]         1 #>   # Continuous variable event_data$rt <- c(1.2, 0.8, 1.1, 0.9) cont_term <- event_term(   list(rt = event_data$rt),   onsets = event_data$onsets,   blockids = event_data$run ) elements(cont_term)  # Returns: c(0.8, 0.9, 1.1, 1.2) #> $rt #>       rt #> [1,] 1.2 #> [2,] 0.8 #> [3,] 1.1 #> [4,] 0.9 #>  # Create event data event_data <- data.frame(   condition = factor(c(\"face\", \"house\", \"face\", \"house\")),   rt = c(0.8, 1.2, 0.9, 1.1),   onsets = c(1, 10, 20, 30),   run = c(1, 1, 1, 1) )  # Create sampling frame sframe <- sampling_frame(blocklens = 50, TR = 2)  # Create event model evmodel <- event_model(   onsets ~ hrf(condition) + hrf(rt),   data = event_data,   block = ~run,   sampling_frame = sframe )  # Plot correlation map for event model correlation_map(evmodel) #> Error in UseMethod(\"correlation_map\"): no applicable method for 'correlation_map' applied to an object of class \"c('event_model', 'list')\"  # Create baseline model bmodel <- baseline_model(   basis = \"bs\",   degree = 3,   sframe = sframe )  # Plot correlation map for baseline model correlation_map(bmodel) #> Error in UseMethod(\"correlation_map\"): no applicable method for 'correlation_map' applied to an object of class \"c('baseline_model', 'list')\"  # Create full model and plot combined correlations fmodel <- fmri_model(evmodel, bmodel) #> Error in eval(assertion, env): argument \"dataset\" is missing, with no default correlation_map(fmodel, method = \"pearson\", half_matrix = TRUE) #> Error: object 'fmodel' not found"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/design_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Design Plot for fMRI Model — design_plot","title":"Design Plot for fMRI Model — design_plot","text":"Generates interactive Shiny app plots design matrix given fMRI model. design matrix first converted long-format tibble plotted time, faceted block. Several customization options allow adjust title, axis labels, line thickness, color palette, .","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/design_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Design Plot for fMRI Model — design_plot","text":"","code":"design_plot(   fmrimod,   term_name = NULL,   longnames = FALSE,   plot_title = NULL,   x_label = \"Time (s)\",   y_label = \"Amplitude\",   line_size = 1,   color_palette = \"viridis\",   facet_ncol = 2,   theme_custom = ggplot2::theme_minimal(base_size = 15) + ggplot2::theme(panel.spacing =     ggplot2::unit(1, \"lines\")),   legend_threshold = 30,   ... )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/design_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Design Plot for fMRI Model — design_plot","text":"fmrimod fmri_model object. term_name Optional: Name term plot. NULL (default), first term used. longnames Logical; TRUE, use long condition names legend. Default FALSE. plot_title Optional plot title. NULL, default title generated. x_label Label x-axis. Default \"Time\". y_label Label y-axis. Default \"Value\". line_size Numeric; line thickness plot. Default 1. color_palette Character; name ColorBrewer palette use (e.g., \"Set1\"). Default \"Set1\". facet_ncol Number columns facet_wrap. Default 1. theme_custom ggplot2 theme apply. Default theme_bw(base_size = 14). legend_threshold Numeric; number unique conditions exceeds value, legend hidden. Default 25. ... Additional arguments passed ggplot2::geom_line().","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/design_plot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Design Plot for fMRI Model — design_plot","text":"Shiny app displays design plot.","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-cleanup_temp_write_dir.html","id":null,"dir":"Reference","previous_headings":"","what":"Clean Up Temporary Write Directory — .cleanup_temp_write_dir","title":"Clean Up Temporary Write Directory — .cleanup_temp_write_dir","text":"Clean Temporary Write Directory","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-cleanup_temp_write_dir.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clean Up Temporary Write Directory — .cleanup_temp_write_dir","text":"","code":".cleanup_temp_write_dir(temp_dir)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-compute_beta_volumes.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Beta Volumes from fmri_lm Object — .compute_beta_volumes","title":"Compute Beta Volumes from fmri_lm Object — .compute_beta_volumes","text":"Compute Beta Volumes fmri_lm Object","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-compute_beta_volumes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Beta Volumes from fmri_lm Object — .compute_beta_volumes","text":"","code":".compute_beta_volumes(fmrilm_obj)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-compute_statistical_volumes.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Statistical Map Volumes from Contrast Data — .compute_statistical_volumes","title":"Compute Statistical Map Volumes from Contrast Data — .compute_statistical_volumes","text":"Compute Statistical Map Volumes Contrast Data","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-compute_statistical_volumes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Statistical Map Volumes from Contrast Data — .compute_statistical_volumes","text":"","code":".compute_statistical_volumes(contrast_data, stat, brain_dims, mask, space)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-create_bids_entities.html","id":null,"dir":"Reference","previous_headings":"","what":"Create BIDS Entities List — .create_bids_entities","title":"Create BIDS Entities List — .create_bids_entities","text":"Create BIDS Entities List","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-create_bids_entities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create BIDS Entities List — .create_bids_entities","text":"","code":".create_bids_entities(subject, task, space)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-create_temp_write_dir.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Temporary Directory for Atomic Writes — .create_temp_write_dir","title":"Create Temporary Directory for Atomic Writes — .create_temp_write_dir","text":"Create Temporary Directory Atomic Writes","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-create_temp_write_dir.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Temporary Directory for Atomic Writes — .create_temp_write_dir","text":"","code":".create_temp_write_dir(base_path)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-extract_contrast_type.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Contrast Type Information — .extract_contrast_type","title":"Extract Contrast Type Information — .extract_contrast_type","text":"Extract Contrast Type Information","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-extract_contrast_type.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Contrast Type Information — .extract_contrast_type","text":"","code":".extract_contrast_type(contrast_row, fmrilm_obj)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-extract_degrees_of_freedom.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Degrees of Freedom from fmri_lm Object — .extract_degrees_of_freedom","title":"Extract Degrees of Freedom from fmri_lm Object — .extract_degrees_of_freedom","text":"Extract Degrees Freedom fmri_lm Object","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-extract_degrees_of_freedom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Degrees of Freedom from fmri_lm Object — .extract_degrees_of_freedom","text":"","code":".extract_degrees_of_freedom(fmrilm_obj)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-extract_source_files.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Source Files from fmri_lm Object — .extract_source_files","title":"Extract Source Files from fmri_lm Object — .extract_source_files","text":"Extract Source Files fmri_lm Object","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-extract_source_files.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Source Files from fmri_lm Object — .extract_source_files","text":"","code":".extract_source_files(fmrilm_obj)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-finalize_atomic_write.html","id":null,"dir":"Reference","previous_headings":"","what":"Finalize Atomic Write by Moving Files — .finalize_atomic_write","title":"Finalize Atomic Write by Moving Files — .finalize_atomic_write","text":"Finalize Atomic Write Moving Files","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-finalize_atomic_write.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finalize Atomic Write by Moving Files — .finalize_atomic_write","text":"","code":".finalize_atomic_write(temp_dir, final_path, created_files)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-generate_bids_filename.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate BIDS-Compliant Filename — .generate_bids_filename","title":"Generate BIDS-Compliant Filename — .generate_bids_filename","text":"Generate BIDS-Compliant Filename","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-generate_bids_filename.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate BIDS-Compliant Filename — .generate_bids_filename","text":"","code":".generate_bids_filename(   entities,   desc = NULL,   contrast = NULL,   stat = NULL,   suffix = NULL,   extension = \"h5\" )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-get_stat_units.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Units for Statistic Type — .get_stat_units","title":"Get Units for Statistic Type — .get_stat_units","text":"Get Units Statistic Type","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-get_stat_units.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Units for Statistic Type — .get_stat_units","text":"","code":".get_stat_units(stat)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-map_stat_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Map User Statistic Names to Internal Field Names — .map_stat_name","title":"Map User Statistic Names to Internal Field Names — .map_stat_name","text":"Map User Statistic Names Internal Field Names","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-map_stat_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map User Statistic Names to Internal Field Names — .map_stat_name","text":"","code":".map_stat_name(stat)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-predict_output_files.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict Output Files for Overwrite Check — .predict_output_files","title":"Predict Output Files for Overwrite Check — .predict_output_files","text":"Predict Output Files Overwrite Check","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-predict_output_files.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict Output Files for Overwrite Check — .predict_output_files","text":"","code":".predict_output_files(   path,   entities,   desc,   strategy,   save_betas,   contrasts,   contrast_stats,   fmrilm_obj )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-resample_param.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate fMRI Time Courses, Return Shared Onsets + Column-Specific Amplitudes/Durations — .resample_param","title":"Simulate fMRI Time Courses, Return Shared Onsets + Column-Specific Amplitudes/Durations — .resample_param","text":"Generates \\(n\\) time-series (columns) single set onsets, resampled amplitudes/durations column amplitude_sd>0 duration_sd>0. column also gets independent noise. result list containing: time_series: matrix_dataset \\(T \\times n\\). event_table uses first column's amplitude/duration draws. ampmat: \\(n\\_events \\times n\\) matrix per-column amplitudes. durmat: \\(n\\_events \\times n\\) matrix per-column durations. hrf_info: info HRF. noise_params: info noise generation (type + AR coefficients + SD).","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-resample_param.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate fMRI Time Courses, Return Shared Onsets + Column-Specific Amplitudes/Durations — .resample_param","text":"","code":".resample_param(   base,   sd,   dist = c(\"lognormal\", \"gamma\", \"gaussian\"),   allow_negative = FALSE )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-resample_param.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate fMRI Time Courses, Return Shared Onsets + Column-Specific Amplitudes/Durations — .resample_param","text":"n Number time-series (columns). total_time Numeric. Total scan length (seconds). TR Numeric. Repetition time (seconds). hrf Hemodynamic response function, e.g. fmrihrf::HRF_SPMG1. n_events Number events (ignored onsets provided). onsets Optional numeric vector event onsets. NULL, generated. isi_dist One \"even\", \"uniform\", \"exponential\". Default \"even\" events evenly spaced 0..total_time. isi_min, isi_max isi_dist=\"uniform\". isi_rate isi_dist=\"exponential\". durations Numeric, scalar length-n_events. duration_sd>0, random sampling done per column. duration_sd Numeric. >0, random variation durations. duration_dist \"lognormal\" \"gamma\" (strictly positive). amplitudes Numeric, scalar length-n_events. amplitude_sd>0, random sampling done per column. amplitude_sd Numeric. >0, random variation amplitudes. amplitude_dist \"lognormal\", \"gamma\", \"gaussian\" (can negative). single_trial TRUE, event separate single-trial regressor gets summed. noise_type \"none\", \"white\", \"ar1\", \"ar2\". noise_ar Numeric vector AR(1) AR(2). missing insufficient, defaults used (0.3 AR(1); c(0.3,0.2) AR(2)). noise_sd Std dev noise. random_seed Optional integer reproducibility. verbose TRUE, prints messages.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-resample_param.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate fMRI Time Courses, Return Shared Onsets + Column-Specific Amplitudes/Durations — .resample_param","text":"list containing: time_series matrix_dataset \\(T \\times n\\) data event_table first column's random draws. ampmat \\(n\\_events \\times n\\) numeric matrix amplitudes. durmat \\(n\\_events \\times n\\) numeric matrix durations. hrf_info list HRF metadata. noise_params list describing noise generation.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-resample_param.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate fMRI Time Courses, Return Shared Onsets + Column-Specific Amplitudes/Durations — .resample_param","text":"noise_type=\"ar1\" provide noise_ar, default c(0.3). noise_type=\"ar2\" provide 2-element noise_ar, default c(0.3, 0.2). Onsets either provided generated columns. Amplitudes/durations re-sampled inside loop column can differ randomly. final arrays ampmat durmat one column per time-series. matrix_dataset's event_table records first column's amplitudes/durations. need column's, see ampmat durmat.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-sanitize_label.html","id":null,"dir":"Reference","previous_headings":"","what":"Sanitize Labels for BIDS Compliance — .sanitize_label","title":"Sanitize Labels for BIDS Compliance — .sanitize_label","text":"Sanitize Labels BIDS Compliance","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-sanitize_label.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sanitize Labels for BIDS Compliance — .sanitize_label","text":"","code":".sanitize_label(label)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-save_betas_json_metadata.html","id":null,"dir":"Reference","previous_headings":"","what":"Save JSON Metadata for Betas — .save_betas_json_metadata","title":"Save JSON Metadata for Betas — .save_betas_json_metadata","text":"Save JSON Metadata Betas","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-save_betas_json_metadata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save JSON Metadata for Betas — .save_betas_json_metadata","text":"","code":".save_betas_json_metadata(   fmrilm_obj,   path,   entities,   desc,   regressor_names,   h5_filepath )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-save_contrasts_by_contrast.html","id":null,"dir":"Reference","previous_headings":"","what":"Save Contrasts by Individual Contrast using LabeledVolumeSet — .save_contrasts_by_contrast","title":"Save Contrasts by Individual Contrast using LabeledVolumeSet — .save_contrasts_by_contrast","text":"Save Contrasts Individual Contrast using LabeledVolumeSet","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-save_contrasts_by_contrast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save Contrasts by Individual Contrast using LabeledVolumeSet — .save_contrasts_by_contrast","text":"","code":".save_contrasts_by_contrast(   fmrilm_obj,   path,   entities,   desc,   contrasts,   contrast_stats,   overwrite )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-save_contrasts_by_stat.html","id":null,"dir":"Reference","previous_headings":"","what":"Save Contrasts by Statistic Type using LabeledVolumeSet — .save_contrasts_by_stat","title":"Save Contrasts by Statistic Type using LabeledVolumeSet — .save_contrasts_by_stat","text":"Save Contrasts Statistic Type using LabeledVolumeSet","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-save_contrasts_by_stat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save Contrasts by Statistic Type using LabeledVolumeSet — .save_contrasts_by_stat","text":"","code":".save_contrasts_by_stat(   fmrilm_obj,   path,   entities,   desc,   contrasts,   contrast_stats,   overwrite )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-save_contrasts_json_metadata.html","id":null,"dir":"Reference","previous_headings":"","what":"Save JSON Metadata for Contrasts (by stat) — .save_contrasts_json_metadata","title":"Save JSON Metadata for Contrasts (by stat) — .save_contrasts_json_metadata","text":"Save JSON Metadata Contrasts (stat)","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-save_contrasts_json_metadata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save JSON Metadata for Contrasts (by stat) — .save_contrasts_json_metadata","text":"","code":".save_contrasts_json_metadata(   fmrilm_obj,   path,   entities,   desc,   stat,   contrast_names,   contrasts,   h5_filepath )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-save_regressor_betas.html","id":null,"dir":"Reference","previous_headings":"","what":"Save Raw Regressor Betas using LabeledVolumeSet — .save_regressor_betas","title":"Save Raw Regressor Betas using LabeledVolumeSet — .save_regressor_betas","text":"Save Raw Regressor Betas using LabeledVolumeSet","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-save_regressor_betas.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save Raw Regressor Betas using LabeledVolumeSet — .save_regressor_betas","text":"","code":".save_regressor_betas(fmrilm_obj, path, entities, desc, overwrite)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-save_single_contrast_json_metadata.html","id":null,"dir":"Reference","previous_headings":"","what":"Save JSON Metadata for Single Contrast — .save_single_contrast_json_metadata","title":"Save JSON Metadata for Single Contrast — .save_single_contrast_json_metadata","text":"Save JSON Metadata Single Contrast","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-save_single_contrast_json_metadata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save JSON Metadata for Single Contrast — .save_single_contrast_json_metadata","text":"","code":".save_single_contrast_json_metadata(   fmrilm_obj,   path,   entities,   desc,   contrast_name,   stat_names,   contrast_row,   h5_filepath )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-update_file_paths_in_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Update File Paths in Results After Atomic Move — .update_file_paths_in_results","title":"Update File Paths in Results After Atomic Move — .update_file_paths_in_results","text":"Update File Paths Results Atomic Move","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-update_file_paths_in_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update File Paths in Results After Atomic Move — .update_file_paths_in_results","text":"","code":".update_file_paths_in_results(created_files, temp_dir, final_path)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-validate_fmrilm_object.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate fmri_lm Object Structure — .validate_fmrilm_object","title":"Validate fmri_lm Object Structure — .validate_fmrilm_object","text":"Validate fmri_lm Object Structure","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-validate_fmrilm_object.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate fmri_lm Object Structure — .validate_fmrilm_object","text":"","code":".validate_fmrilm_object(x)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-validate_required_entities.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate Required BIDS Entities — .validate_required_entities","title":"Validate Required BIDS Entities — .validate_required_entities","text":"Validate Required BIDS Entities","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/dot-validate_required_entities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate Required BIDS Entities — .validate_required_entities","text":"","code":".validate_required_entities(entities)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/estimate_betas.fmri_dataset.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate betas using various regression methods — estimate_betas.fmri_dataset","title":"Estimate betas using various regression methods — estimate_betas.fmri_dataset","text":"function estimates betas (regression coefficients) fixed random effects using various regression methods including mixed models, least squares, PLS.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/estimate_betas.fmri_dataset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate betas using various regression methods — estimate_betas.fmri_dataset","text":"","code":"# S3 method for class 'fmri_dataset' estimate_betas(   x,   fixed = NULL,   ran,   block,   method = c(\"mixed\", \"mixed_cpp\", \"lss\", \"lss_naive\", \"lss_cpp\", \"pls\", \"pls_global\",     \"ols\"),   basemod = NULL,   maxit = 1000,   fracs = 0.5,   progress = TRUE,   ... )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/estimate_betas.fmri_dataset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate betas using various regression methods — estimate_betas.fmri_dataset","text":"x object class fmri_dataset representing fMRI dataset. fixed formula specifying fixed regressors model constant effects (.e., non-varying trials). ran formula specifying random (trialwise) regressors model single trial effects. block formula specifying block factor. method regression method estimating trialwise betas; one \"mixed\", \"mixed_cpp\", \"lss\", \"lss_naive\", \"lss_cpp\", \"pls\", \"pls_global\", \"ols\". basemod baseline_model instance regress data beta estimation (default: NULL). maxit Maximum number iterations optimization methods (default: 1000). fracs Fraction voxels used prewhitening. progress Logical; show progress bar. ... Additional arguments passed estimation method.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/estimate_betas.fmri_dataset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate betas using various regression methods — estimate_betas.fmri_dataset","text":"list class \"fmri_betas\" containing following components: betas_fixed: NeuroVec object representing fixed effect betas. betas_ran: NeuroVec object representing random effect betas. design_ran: Design matrix random effects. design_fixed: Design matrix fixed effects. design_base: Design matrix baseline model. basemod: Baseline model object. fixed_model: Fixed effect model object. ran_model: Random effect model object. estimated_hrf: estimated HRF vector (NULL methods).","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/estimate_betas.fmri_dataset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate betas using various regression methods — estimate_betas.fmri_dataset","text":"","code":"if (FALSE) { # \\dontrun{ facedes <- read.table(system.file(\"extdata\", \"face_design.txt\", package = \"fmrireg\"), header=TRUE) facedes$frun <- factor(facedes$run) scans <- paste0(\"rscan0\", 1:6, \".nii\")  dset <- fmri_dataset(scans=scans, mask=\"mask.nii\", TR=1.5,          run_length=rep(436,6), event_table=facedes) fixed = onset ~ hrf(run) ran = onset ~ trialwise() block = ~ run  betas <- estimate_betas(dset, fixed=fixed, ran=ran, block=block, method=\"mixed\") } # }"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/estimate_betas.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Beta Coefficients for fMRI Data — estimate_betas","title":"Estimate Beta Coefficients for fMRI Data — estimate_betas","text":"Estimate beta coefficients (regression parameters) fMRI data using various methods. function supports different estimation approaches : single Single-trial beta estimation effects Fixed random effects regularization Various regularization techniques hrf Optional HRF estimation function estimates betas (regression coefficients) fixed random effects matrix dataset using various methods.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/estimate_betas.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Beta Coefficients for fMRI Data — estimate_betas","text":"","code":"estimate_betas(x, ...)  # S3 method for class 'latent_dataset' estimate_betas(   x,   fixed = NULL,   ran,   block,   method = c(\"mixed\", \"pls\", \"pls_global\", \"ols\"),   basemod = NULL,   ncomp = 4,   lambda = 0.01,   prewhiten = FALSE,   progress = TRUE,   ... )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/estimate_betas.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Beta Coefficients for fMRI Data — estimate_betas","text":"x object class matrix_dataset representing matrix dataset ... Additional arguments passed estimation method fixed formula specifying fixed regressors model constant effects (.e., non-varying trials) ran formula specifying random (trialwise) regressors model single trial effects block formula specifying block factor method regression method estimating trialwise betas; one \"mixed\", \"pls\", \"pls_global\", \"ols\" (default: \"mixed\") basemod baseline_model instance regress data beta estimation (default: NULL) ncomp Number PLS components \"pls\" \"pls_global\" methods (default: 4) lambda Lambda parameter (currently used; default: 0.01) prewhiten currently experimental, default FALSE. progress Logical; show progress bar.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/estimate_betas.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Beta Coefficients for fMRI Data — estimate_betas","text":"list class \"fmri_betas\" containing: betas_fixed Fixed effect coefficients betas_ran Random (trial-wise) coefficients design_ran Design matrix random effects design_fixed Design matrix fixed effects design_base Design matrix baseline model method_specific Additional components specific estimation method used list class \"fmri_betas\" containing following components: betas_fixed: Matrix representing fixed effect betas betas_ran: Matrix representing random effect betas design_ran: Design matrix random effects design_fixed: Design matrix fixed effects design_base: Design matrix baseline model","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/estimate_betas.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate Beta Coefficients for fMRI Data — estimate_betas","text":"generic function methods different dataset types: fmri_dataset volumetric fMRI data matrix_dataset matrix-format data latent_dataset dimensionality-reduced data Available estimation methods include: mixed Mixed-effects model using rrBLUP r1 Rank-1 GLM joint HRF estimation lss Least-squares separate estimation pls Partial least squares regression ols Ordinary least squares","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/estimate_betas.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Estimate Beta Coefficients for fMRI Data — estimate_betas","text":"Mumford, J. ., et al. (2012). Deconvolving BOLD activation event-related designs multivoxel pattern classification analyses. NeuroImage, 59(3), 2636-2643. Pedregosa, F., et al. (2015). Data-driven HRF estimation encoding decoding models. NeuroImage, 104, 209-220.","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/estimate_betas.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Beta Coefficients for fMRI Data — estimate_betas","text":"","code":"# Create example data event_data <- data.frame(   condition = factor(c(\"A\", \"B\", \"A\", \"B\")),   onsets = c(1, 10, 20, 30),   run = c(1, 1, 1, 1) )  # Create sampling frame and dataset sframe <- sampling_frame(blocklens = 50, TR = 2) dset <- fmridataset::matrix_dataset(   matrix(rnorm(100 * 2), 100, 2),   TR = 2,   run_length = 50,   event_table = event_data ) #> Error: sum(run_length) not equal to nrow(datamat)  # Estimate betas using mixed-effects model betas <- estimate_betas(   dset,   fixed = onset ~ hrf(condition),   ran = onset ~ trialwise(),   block = ~run,   method = \"mixed\" ) #> Error: object 'dset' not found"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/estimate_betas.matrix_dataset.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate betas for a matrix dataset — estimate_betas.matrix_dataset","title":"Estimate betas for a matrix dataset — estimate_betas.matrix_dataset","text":"function estimates betas (regression coefficients) fixed random effects matrix dataset using various methods.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/estimate_betas.matrix_dataset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate betas for a matrix dataset — estimate_betas.matrix_dataset","text":"","code":"# S3 method for class 'matrix_dataset' estimate_betas(   x,   fixed = NULL,   ran,   block,   method = c(\"lss\", \"lss_cpp\", \"lss_naive\", \"mixed\", \"mixed_cpp\", \"pls\", \"pls_global\",     \"ols\"),   basemod = NULL,   ncomp = 4,   lambda = 0.01,   fracs = 0.5,   progress = TRUE,   ... )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/estimate_betas.matrix_dataset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate betas for a matrix dataset — estimate_betas.matrix_dataset","text":"x object class matrix_dataset representing matrix dataset fixed formula specifying fixed regressors model constant effects (.e., non-varying trials) ran formula specifying random (trialwise) regressors model single trial effects block formula specifying block factor method regression method estimating trialwise betas; one \"mixed\", \"pls\", \"pls_global\", \"ols\" (default: \"mixed\") basemod baseline_model instance regress data beta estimation (default: NULL) ncomp Number PLS components \"pls\" \"pls_global\" methods (default: 4) lambda Lambda parameter (currently used; default: 0.01) fracs Fraction voxels used prewhitening. progress Logical; show progress bar. ... Additional arguments passed estimation method","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/estimate_betas.matrix_dataset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate betas for a matrix dataset — estimate_betas.matrix_dataset","text":"list class \"fmri_betas\" containing following components: betas_fixed: Matrix representing fixed effect betas betas_ran: Matrix representing random effect betas design_ran: Design matrix random effects design_fixed: Design matrix fixed effects design_base: Design matrix baseline model","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/estimate_hrf.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate hemodynamic response function (HRF) using Generalized Additive Models (GAMs) — estimate_hrf","title":"Estimate hemodynamic response function (HRF) using Generalized Additive Models (GAMs) — estimate_hrf","text":"function estimates HRF using GAMs mgcv package. HRF can estimated without fixed effects.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/estimate_hrf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate hemodynamic response function (HRF) using Generalized Additive Models (GAMs) — estimate_hrf","text":"","code":"estimate_hrf(   form,   fixed = NULL,   block,   dataset,   bs = c(\"tp\", \"ts\", \"cr\", \"ps\"),   rsam = seq(0, 20, by = 1),   basemod = NULL,   k = 8,   fx = TRUE,   progress = TRUE )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/estimate_hrf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate hemodynamic response function (HRF) using Generalized Additive Models (GAMs) — estimate_hrf","text":"form formula specifying event model conditions interest fixed formula specifying fixed regressors model constant effects (.e., non-varying trials); default NULL block formula specifying block factor dataset object representing fMRI dataset bs Basis function smooth term GAM; one \"tp\" (default), \"ts\", \"cr\", \"ps\" rsam sequence time points HRF estimated (default: seq(0, 20, = 1)) basemod baseline_model instance regress data HRF estimation (default: NULL) k dimension basis, default 8 fx indicates whether term fixed d.f. regression spline (TRUE) penalized regression spline (FALSE); default TRUE. progress Logical; display progress estimation.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/estimate_hrf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate hemodynamic response function (HRF) using Generalized Additive Models (GAMs) — estimate_hrf","text":"matrix estimated HRF values voxel","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/estimate_hrf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate hemodynamic response function (HRF) using Generalized Additive Models (GAMs) — estimate_hrf","text":"","code":"# To be added"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/evaluate_method_performance.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate Method Performance on Benchmark Dataset — evaluate_method_performance","title":"Evaluate Method Performance on Benchmark Dataset — evaluate_method_performance","text":"Helper function evaluate performance beta estimation methods benchmark datasets comparing estimated betas ground truth.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/evaluate_method_performance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate Method Performance on Benchmark Dataset — evaluate_method_performance","text":"","code":"evaluate_method_performance(   dataset_name,   estimated_betas,   method_name = \"Unknown\" )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/evaluate_method_performance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate Method Performance on Benchmark Dataset — evaluate_method_performance","text":"dataset_name Character string specifying dataset use estimated_betas Matrix estimated beta values (conditions x voxels) method_name Character string describing method used","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/evaluate_method_performance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate Method Performance on Benchmark Dataset — evaluate_method_performance","text":"list performance metrics","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/evaluate_method_performance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate Method Performance on Benchmark Dataset — evaluate_method_performance","text":"","code":"if (FALSE) { # \\dontrun{ # Load dataset and create design matrix dataset <- load_benchmark_dataset(\"BM_Canonical_HighSNR\") X <- create_design_matrix_from_benchmark(\"BM_Canonical_HighSNR\", fmrihrf::HRF_SPMG1)  # Fit simple linear model betas <- solve(t(X) %*% X) %*% t(X) %*% dataset$Y_noisy  # Evaluate performance performance <- evaluate_method_performance(\"BM_Canonical_HighSNR\",                                            betas[-1, ], # Remove intercept                                           \"OLS\") } # }"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/event_table.convolved_term.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract event table from convolved term — event_table.convolved_term","title":"Extract event table from convolved term — event_table.convolved_term","text":"Extract event table convolved term object.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/event_table.convolved_term.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract event table from convolved term — event_table.convolved_term","text":"","code":"# S3 method for class 'convolved_term' event_table(x)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/event_table.convolved_term.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract event table from convolved term — event_table.convolved_term","text":"x convolved_term object","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/event_table.convolved_term.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract event table from convolved term — event_table.convolved_term","text":"data.frame containing event table","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fit_contrasts.default.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit Contrasts for Linear Model (Default Method) — fit_contrasts.default","title":"Fit Contrasts for Linear Model (Default Method) — fit_contrasts.default","text":"function calculates contrasts fitted linear model.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fit_contrasts.default.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit Contrasts for Linear Model (Default Method) — fit_contrasts.default","text":"","code":"# Default S3 method fit_contrasts(object, conmat, colind, se = TRUE, ...)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fit_contrasts.default.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit Contrasts for Linear Model (Default Method) — fit_contrasts.default","text":"object fitted linear model object. conmat contrast matrix contrast vector. colind subset column indices design associated contrast. se Whether compute standard errors, t-statistics, p-values (default: TRUE). ... Additional arguments (unused)","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fit_contrasts.default.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit Contrasts for Linear Model (Default Method) — fit_contrasts.default","text":"list containing following elements: conmat: Contrast matrix. sigma: Residual standard error. df.residual: Degrees freedom residuals. estimate: Estimated contrasts. se: Standard errors contrasts (se = TRUE). stat: t-statistics contrasts (se = TRUE). prob: Probabilities associated t-statistics (se = TRUE). stat_type: Type statistics calculated.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fit_contrasts.fmri_lm.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit Contrasts for fMRI Linear Model Objects — fit_contrasts.fmri_lm","title":"Fit Contrasts for fMRI Linear Model Objects — fit_contrasts.fmri_lm","text":"S3 method computing contrasts fitted fmri_lm objects.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fit_contrasts.fmri_lm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit Contrasts for fMRI Linear Model Objects — fit_contrasts.fmri_lm","text":"","code":"# S3 method for class 'fmri_lm' fit_contrasts(object, contrasts, ...)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fit_contrasts.fmri_lm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit Contrasts for fMRI Linear Model Objects — fit_contrasts.fmri_lm","text":"object fmri_lm object contrasts list contrast specifications ... Additional arguments (unused)","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fit_contrasts.fmri_lm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit Contrasts for fMRI Linear Model Objects — fit_contrasts.fmri_lm","text":"list contrast results","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fit_contrasts.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit Contrasts — fit_contrasts","title":"Fit Contrasts — fit_contrasts","text":"Generic function fitting contrasts model objects.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fit_contrasts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit Contrasts — fit_contrasts","text":"","code":"fit_contrasts(object, ...)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fit_contrasts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit Contrasts — fit_contrasts","text":"object fitted model object ... Additional arguments passed methods","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fit_contrasts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit Contrasts — fit_contrasts","text":"Contrast results (format depends method)","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fit_lm_contrasts.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit Linear Model Contrasts — fit_lm_contrasts","title":"Fit Linear Model Contrasts — fit_lm_contrasts","text":"function computes contrasts beta statistics fitted linear model.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fit_lm_contrasts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit Linear Model Contrasts — fit_lm_contrasts","text":"","code":"fit_lm_contrasts(fit, conlist, fcon, vnames, se = TRUE)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fit_lm_contrasts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit Linear Model Contrasts — fit_lm_contrasts","text":"fit fitted linear model object. conlist list contrast matrices. fcon list F-contrasts. vnames Variable names corresponding model coefficients. se Logical. Whether compute standard errors. Default TRUE.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fit_lm_contrasts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit Linear Model Contrasts — fit_lm_contrasts","text":"list containing contrasts, beta statistics, fitted model.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fitted_hrf.fmri_lm.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract HRF from Fitted Model — fitted_hrf.fmri_lm","title":"Extract HRF from Fitted Model — fitted_hrf.fmri_lm","text":"method computes fitted hemodynamic response functions (HRFs) fmri_lm object.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fitted_hrf.fmri_lm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract HRF from Fitted Model — fitted_hrf.fmri_lm","text":"","code":"# S3 method for class 'fmri_lm' fitted_hrf(x, sample_at = seq(0, 24, by = 1), ...)  # S3 method for class 'fmri_lm' fitted_hrf(x, sample_at = seq(0, 24, by = 1), ...)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fitted_hrf.fmri_lm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract HRF from Fitted Model — fitted_hrf.fmri_lm","text":"x fmri_lm object fitted HRFs computed. sample_at numeric vector time points HRFs sampled. Default seq(0, 24, = 1). ... Additional arguments (currently unused).","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fitted_hrf.fmri_lm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract HRF from Fitted Model — fitted_hrf.fmri_lm","text":"data frame fitted HRF list element corresponds event term fmri_lm object. element contains: pred matrix predicted HRF values. design tibble containing design matrix HRFs.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fitted_hrf.html","id":null,"dir":"Reference","previous_headings":"","what":"fitted_hrf — fitted_hrf","title":"fitted_hrf — fitted_hrf","text":"Compute return fitted hemodynamic response function (HRF) model object. HRF represents expected BOLD response neural activity. models multiple basis functions, returns combined HRF shape.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fitted_hrf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"fitted_hrf — fitted_hrf","text":"","code":"fitted_hrf(x, sample_at, ...)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fitted_hrf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"fitted_hrf — fitted_hrf","text":"x object fitted HRF computed sample_at vector time points HRF sampled ... Additional arguments passed methods","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fitted_hrf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"fitted_hrf — fitted_hrf","text":"numeric vector containing fitted HRF values requested time points","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fitted_hrf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"fitted_hrf — fitted_hrf","text":"generic function computes fitted hemodynamic response function (HRF) object. method needs implemented specific object types.","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fitted_hrf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"fitted_hrf — fitted_hrf","text":"","code":"# Create a simple dataset with two conditions X <- matrix(rnorm(100 * 100), 100, 100)  # 100 timepoints, 100 voxels event_data <- data.frame(   condition = factor(c(\"A\", \"B\", \"A\", \"B\")),   onsets = c(1, 25, 50, 75),   run = c(1, 1, 1, 1) )  # Create dataset and sampling frame dset <- fmridataset::matrix_dataset(X, TR = 2, run_length = 100, event_table = event_data) sframe <- sampling_frame(blocklens = 100, TR = 2)  # Create event model with canonical HRF evmodel <- event_model(   onsets ~ hrf(condition),   data = event_data,   block = ~run,   sampling_frame = sframe )  # Fit model fit <- fmri_lm(   onsets ~ hrf(condition),   block = ~run,   dataset = dset )  # Get fitted HRF at specific timepoints times <- seq(0, 20, by = 0.5)  # Sample from 0-20s every 0.5s hrf_values <- fitted_hrf(fit, sample_at = times) #> Error in names(pred) <- names(eterms): 'names' attribute [1] must be the same length as the vector [0]"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_benchmark_datasets.html","id":null,"dir":"Reference","previous_headings":"","what":"Benchmark fMRI datasets — fmri_benchmark_datasets","title":"Benchmark fMRI datasets — fmri_benchmark_datasets","text":"list simulated datasets used testing package.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_benchmark_datasets.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Benchmark fMRI datasets — fmri_benchmark_datasets","text":"list elements BM_Canonical_HighSNR, BM_Canonical_LowSNR, BM_HRF_Variability_AcrossVoxels, BM_Trial_Amplitude_Variability, BM_Complex_Realistic, metadata. element contains simulated BOLD data ground truth information.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_benchmark_datasets.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Benchmark fMRI datasets — fmri_benchmark_datasets","text":"Generated data-raw/generate_benchmark_datasets.R","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_latent_lm.html","id":null,"dir":"Reference","previous_headings":"","what":"Fast fMRI Regression Model Estimation from a Latent Component Dataset — fmri_latent_lm","title":"Fast fMRI Regression Model Estimation from a Latent Component Dataset — fmri_latent_lm","text":"function estimates regression model fMRI data using latent component dataset. dataset must type latent_dataset, requires LatentNeuroVec input.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_latent_lm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fast fMRI Regression Model Estimation from a Latent Component Dataset — fmri_latent_lm","text":"","code":"fmri_latent_lm(   formula,   block,   baseline_model = NULL,   dataset,   durations,   drop_empty = TRUE,   robust = FALSE,   autocor = c(\"none\", \"auto\", \"ar1\", \"ar2\", \"arma\"),   bootstrap = FALSE,   nboot = 1000,   ... )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_latent_lm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fast fMRI Regression Model Estimation from a Latent Component Dataset — fmri_latent_lm","text":"formula formula specifying regression model. block factor indicating block structure data. baseline_model optional baseline model. dataset dataset class 'latent_dataset'. durations duration events dataset. drop_empty Whether drop empty events model. Default TRUE. robust Whether use robust regression methods. Default FALSE. autocor autocorrelation correction method use components. One 'none', 'auto', 'ar1', 'ar2', 'arma'. Default 'none'. bootstrap Whether compute bootstrapped parameter estimates. Default FALSE. nboot number bootstrap iterations. Default 1000. ... Additional arguments.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_latent_lm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fast fMRI Regression Model Estimation from a Latent Component Dataset — fmri_latent_lm","text":"object class 'fmri_latent_lm' containing regression model dataset.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_latent_lm.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Fast fMRI Regression Model Estimation from a Latent Component Dataset — fmri_latent_lm","text":"method currently experimental.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_latent_lm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fast fMRI Regression Model Estimation from a Latent Component Dataset — fmri_latent_lm","text":"","code":"# Estimate the fMRI regression model using the latent dataset #result <- fmri_latent_lm(formula = formula, block = block, dataset = dset, #                          durations = NULL, drop_empty = TRUE, robust = FALSE)  # Print the result #print(result)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_lm.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a Linear Regression Model for fMRI Data Analysis — fmri_lm","title":"Fit a Linear Regression Model for fMRI Data Analysis — fmri_lm","text":"fmri_lm generic fitting fMRI regression models. default interface accepts model formula dataset. alternative method can used preconstructed fmri_model object already contains design data.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_lm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a Linear Regression Model for fMRI Data Analysis — fmri_lm","text":"","code":"fmri_lm(formula, ...)  # S3 method for class 'formula' fmri_lm(   formula,   block,   baseline_model = NULL,   dataset,   durations = 0,   drop_empty = TRUE,   robust = FALSE,   robust_options = NULL,   ar_options = NULL,   strategy = c(\"runwise\", \"chunkwise\"),   nchunks = 10,   use_fast_path = FALSE,   progress = FALSE,   ar_voxelwise = FALSE,   parallel_voxels = FALSE,   cor_struct = NULL,   cor_iter = NULL,   cor_global = NULL,   ar1_exact_first = NULL,   ar_p = NULL,   robust_psi = NULL,   robust_max_iter = NULL,   robust_scale_scope = NULL,   ... )  # S3 method for class 'fmri_model' fmri_lm(   fmrimod,   dataset = NULL,   robust = FALSE,   robust_options = NULL,   ar_options = NULL,   strategy = c(\"runwise\", \"chunkwise\"),   nchunks = 10,   use_fast_path = FALSE,   progress = FALSE,   ar_voxelwise = FALSE,   parallel_voxels = FALSE,   cor_struct = NULL,   cor_iter = NULL,   cor_global = NULL,   ar1_exact_first = NULL,   ar_p = NULL,   robust_psi = NULL,   robust_max_iter = NULL,   robust_scale_scope = NULL,   ... )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_lm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a Linear Regression Model for fMRI Data Analysis — fmri_lm","text":"formula model formula describing event structure fmri_model object. ... Additional arguments passed chosen method. block model formula block structure. baseline_model (Optional) baseline_model object. Default NULL. dataset fmri_dataset object containing time-series data. durations vector event durations. Default 0. drop_empty Logical. Whether remove factor levels zero size. Default TRUE. robust Logical character. Either FALSE (robust fitting), TRUE (use Huber), one \"huber\" \"bisquare\". Default FALSE. robust_options List robust fitting options. See Details. ar_options List autoregressive modeling options. See Details. strategy data splitting strategy, either \"runwise\" \"chunkwise\". Default \"runwise\". nchunks Number data chunks strategy \"chunkwise\". Default 10. use_fast_path Logical. TRUE, use matrix-based computation speed. Default FALSE. progress Logical. Whether display progress bar model fitting. Default FALSE.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_lm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a Linear Regression Model for fMRI Data Analysis — fmri_lm","text":"object class fmri_lm. fitted linear regression model fMRI data analysis.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_lm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit a Linear Regression Model for fMRI Data Analysis — fmri_lm","text":"robust_options may contain: type: Character logical. Type robust fitting (FALSE, \"huber\", \"bisquare\") k_huber: Numeric. Tuning constant Huber's psi (default: 1.345) c_tukey: Numeric. Tuning constant Tukey's bisquare psi (default: 4.685) max_iter: Integer. Maximum IRLS iterations (default: 2) scale_scope: Character. Scope scale estimation (\"run\" \"global\") reestimate_phi: Logical. Whether re-estimate AR parameters robust fitting ar_options may contain: struct: Character. Correlation structure (\"iid\", \"ar1\", \"ar2\", \"arp\") p: Integer. AR order struct = \"arp\" iter_gls: Integer. Number GLS iterations (default: 1) global: Logical. Use global AR coefficients (default: FALSE) voxelwise: Logical. Estimate AR parameters voxel-wise (default: FALSE) exact_first: Logical. Apply exact AR(1) scaling first sample (default: FALSE)","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_lm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a Linear Regression Model for fMRI Data Analysis — fmri_lm","text":"","code":"facedes <- subset(read.table(system.file(\"extdata\", \"face_design.txt\", package = \"fmrireg\"),  header=TRUE), face_gen != \"n/a\") facedes$face_gen <- droplevels(factor(facedes$face_gen)) sframe <- sampling_frame(rep(430/2,6), TR=2) ev <- event_model(onset ~ hrf(face_gen, basis=\"gaussian\"), data=facedes,  block= ~ run, sampling_frame=sframe) globonsets <- fmrihrf::global_onsets(sframe, facedes$onset, fmrihrf::blockids(ev)) #> Error in UseMethod(\"blockids\"): no applicable method for 'blockids' applied to an object of class \"c('event_model', 'list')\" reg1_signal <- regressor(globonsets[facedes$face_gen == \"male\"], hrf=HRF_GAUSSIAN) #> Error: object 'globonsets' not found reg2_signal <- regressor(globonsets[facedes$face_gen == \"female\"], hrf=HRF_GAUSSIAN) #> Error: object 'globonsets' not found time <- samples(sframe, global=TRUE) y1 <- fmrihrf::evaluate(reg1_signal, time)*1.5 #> Error: object 'reg1_signal' not found y2 <- fmrihrf::evaluate(reg2_signal, time)*3.0 #> Error: object 'reg2_signal' not found y <- y1+y2 #> Error: object 'y1' not found ys1 <- y + rnorm(length(y), sd=.02) #> Error: object 'y' not found ys2 <- y + rnorm(length(y), sd=.02) #> Error: object 'y' not found  h <<- gen_hrf(hrf_bspline, N=7, span=25) #> Error: object 'hrf_bspline' not found dset <- matrix_dataset(cbind(ys1,ys2), TR=2, run_length=fmrihrf::blocklens(sframe), event_table=facedes) #> Error: object 'ys1' not found flm <- fmri_lm(onset ~ hrf(face_gen, basis=gen_hrf(hrf_bspline, N=7, span=25)), block = ~ run,  strategy=\"chunkwise\", nchunks=1, dataset=dset) #> Error: object 'dset' not found"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_lm_control.html","id":null,"dir":"Reference","previous_headings":"","what":"Configuration for fmri_lm fitting — fmri_lm_control","title":"Configuration for fmri_lm fitting — fmri_lm_control","text":"fmri_lm_control() creates fmri_lm_config object collecting options robust autoregressive modelling. validates inputs applies defaults downstream functions receive single structured list.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_lm_control.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Configuration for fmri_lm fitting — fmri_lm_control","text":"","code":"fmri_lm_control(robust_options = list(), ar_options = list())"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_lm_control.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Configuration for fmri_lm fitting — fmri_lm_control","text":"robust_options list robust fitting options. See Details. ar_options list autoregressive modelling options. See Details.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_lm_control.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Configuration for fmri_lm fitting — fmri_lm_control","text":"object class fmri_lm_config.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_lm_control.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Configuration for fmri_lm fitting — fmri_lm_control","text":"robust_options may contain: type (FALSE, \"huber\", \"bisquare\") k_huber c_tukey max_iter scale_scope (\"run\", \"global\") reestimate_phi (logical) ar_options may contain: struct (\"iid\", \"ar1\", \"ar2\", \"arp\") p (order \"arp\") iter_gls (integer number GLS iterations) global (logical, use global phi) voxelwise (logical) exact_first (logical)","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_lm_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit an fMRI Linear Regression Model with a Specified Fitting Strategy — fmri_lm_fit","title":"Fit an fMRI Linear Regression Model with a Specified Fitting Strategy — fmri_lm_fit","text":"function fits fMRI linear regression model using specified fmri_model object, dataset, data splitting strategy (either \"runwise\" \"chunkwise\"). primarily internal function used fmri_lm function.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_lm_fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit an fMRI Linear Regression Model with a Specified Fitting Strategy — fmri_lm_fit","text":"","code":"fmri_lm_fit(   fmrimod,   dataset,   strategy = c(\"runwise\", \"chunkwise\"),   cfg,   nchunks = 10,   use_fast_path = FALSE,   progress = FALSE,   parallel_voxels = FALSE,   ... )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_lm_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit an fMRI Linear Regression Model with a Specified Fitting Strategy — fmri_lm_fit","text":"fmrimod fmri_model object. dataset fmri_dataset object containing time-series data. strategy data splitting strategy, either \"runwise\" \"chunkwise\". Default \"runwise\". cfg fmri_lm_config object containing fitting options. See fmri_lm_control. nchunks Number data chunks strategy \"chunkwise\". Default 10. use_fast_path Logical. TRUE, use matrix-based computation speed. Default FALSE. progress Logical. Whether display progress bar model fitting. Default FALSE. parallel_voxels Logical. TRUE, voxelwise AR processing within runs parallelised using future.apply. Default FALSE. ... Additional arguments.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_lm_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit an fMRI Linear Regression Model with a Specified Fitting Strategy — fmri_lm_fit","text":"fitted fMRI linear regression model specified fitting strategy.","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct an fMRI Regression Model — fmri_model","title":"Construct an fMRI Regression Model — fmri_model","text":"function constructs fMRI regression model consisting event model baseline model. resulting model can used analysis fMRI data.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct an fMRI Regression Model — fmri_model","text":"","code":"fmri_model(event_model, baseline_model, dataset)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct an fMRI Regression Model — fmri_model","text":"event_model object class \"event_model\" representing event-related part fMRI regression model. baseline_model object class \"baseline_model\" representing baseline-related part fMRI regression model. dataset fmri_dataset used build model.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct an fMRI Regression Model — fmri_model","text":"object class fmri_model containing event baseline models along dataset.","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_rlm.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a Robust Linear Model for fMRI Data Analysis — fmri_rlm","title":"Fit a Robust Linear Model for fMRI Data Analysis — fmri_rlm","text":"function fits robust linear regression model fMRI data analysis using specified model formula, block structure, dataset. model can fit using either runwise chunkwise data splitting strategy.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_rlm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a Robust Linear Model for fMRI Data Analysis — fmri_rlm","text":"","code":"fmri_rlm(   formula,   block,   baseline_model = NULL,   dataset,   durations = 0,   drop_empty = TRUE,   strategy = c(\"runwise\", \"chunkwise\"),   nchunks = 10,   cor_struct = c(\"iid\", \"ar1\", \"ar2\", \"arp\"),   cor_iter = 1L,   cor_global = FALSE,   ar_p = NULL,   ar1_exact_first = FALSE,   robust_psi = c(\"huber\", \"bisquare\"),   robust_k_huber = 1.345,   robust_c_tukey = 4.685,   robust_max_iter = 2L,   robust_scale_scope = c(\"run\", \"global\"),   ... )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_rlm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a Robust Linear Model for fMRI Data Analysis — fmri_rlm","text":"formula model formula describing event structure fmri_model object. block model formula block structure. baseline_model (Optional) baseline_model object. Default NULL. dataset fmri_dataset object containing time-series data. durations vector event durations. Default 0. drop_empty Logical. Whether remove factor levels zero size. Default TRUE. strategy data splitting strategy, either \"runwise\" \"chunkwise\". Default \"runwise\". nchunks Number data chunks strategy \"chunkwise\". Default 10. cor_struct Correlation structure: \"iid\", \"ar1\", \"ar2\", \"arp\". Default \"iid\". cor_iter Number iterations AR parameter estimation. Default 1. cor_global Whether use global AR parameters. Default FALSE. ar_p Order autoregressive model \"arp\" structure. Default NULL. ar1_exact_first Whether use exact AR(1) first iteration. Default FALSE. robust_psi Robust psi function: \"huber\" \"bisquare\". Default \"huber\". robust_k_huber Tuning constant Huber's psi. Default 1.345. robust_c_tukey Tuning constant Tukey's bisquare. Default 4.685. robust_max_iter Maximum iterations robust fitting. Default 2. robust_scale_scope Scope robust scale estimation: \"run\" \"global\". Default \"run\". ... Additional arguments passed fmri_lm","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_rlm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a Robust Linear Model for fMRI Data Analysis — fmri_rlm","text":"fitted robust linear regression model fMRI data analysis.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmri_rlm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a Robust Linear Model for fMRI Data Analysis — fmri_rlm","text":"","code":"etab <- data.frame(onset=c(1,30,15,25), fac=factor(c(\"A\", \"B\", \"A\", \"B\")), run=c(1,1,2,2)) etab2 <- data.frame(onset=c(1,30,65,75), fac=factor(c(\"A\", \"B\", \"A\", \"B\")), run=c(1,1,1,1)) mat <- matrix(rnorm(100*100), 100,100) dset <- fmridataset::matrix_dataset(mat, TR=1, run_length=c(50,50),event_table=etab) dset2 <- fmridataset::matrix_dataset(mat, TR=1, run_length=c(100),event_table=etab2) lm.1 <- fmri_rlm(onset ~ hrf(fac), block= ~ run, dataset=dset) #> Error in unlist(cres, recursive = FALSE) %>% dplyr::bind_rows(): could not find function \"%>%\" lm.2 <- fmri_rlm(onset ~ hrf(fac), block= ~ run, dataset=dset2)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmrireg-package.html","id":null,"dir":"Reference","previous_headings":"","what":"fmrireg: regression tools for fMRI data — fmrireg-package","title":"fmrireg: regression tools for fMRI data — fmrireg-package","text":"fmrireg provides functions generating experimental design matrices appropriate analyzing fMRI data regression.","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/fmrireg-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"fmrireg: regression tools for fMRI data — fmrireg-package","text":"Maintainer: Bradley Buchsbaum brad.buchsbaum@gmail.com","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/generate_interaction_contrast.html","id":null,"dir":"Reference","previous_headings":"","what":"Fast factorial contrast generators — generate_interaction_contrast","title":"Fast factorial contrast generators — generate_interaction_contrast","text":"Returns matrix N_cells × N_contrasts – row design cell, columns independent contrasts (difference‑coded factors ask , grand‑mean rest).  Suitable tcrossprod(dm, C) lm.fit(design, y) followed %*% coef usual way.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/generate_interaction_contrast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fast factorial contrast generators — generate_interaction_contrast","text":"","code":"generate_interaction_contrast(des, factors)  generate_main_effect_contrast(des, factor)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/generate_interaction_contrast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fast factorial contrast generators — generate_interaction_contrast","text":"des data.frame one column per factor (must factor) factors character vector: factor(s) get difference coding. • generate_main_effect_contrast() takes single factor name. • generate_interaction_contrast() takes ≥ 2 interaction (1 reproduce main‑effect matrix). factor Single factor name main effect.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/generate_interaction_contrast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fast factorial contrast generators — generate_interaction_contrast","text":"numeric matrix nrow = ∏ levels(f) , ncol = ∏ (Lᵢ − 1) chosen factors.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/generate_interaction_contrast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fast factorial contrast generators — generate_interaction_contrast","text":"","code":"des <- expand.grid(Time = factor(1:4),                    Cond = factor(c(\"face\",\"scene\")))  # Main effect of Time (4‑1 = 3 contrasts) M <- generate_main_effect_contrast(des, \"Time\")  # Full Time×Cond interaction ( (4‑1)*(2‑1) = 3 contrasts ) I <- generate_interaction_contrast(des, c(\"Time\",\"Cond\")) dim(I)   # 8 rows (cells) × 3 columns (contrasts) #> [1] 8 3"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/get_benchmark_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Benchmark Dataset Summary — get_benchmark_summary","title":"Get Benchmark Dataset Summary — get_benchmark_summary","text":"Provides detailed summary specific benchmark dataset including dimensions, experimental design, ground truth information.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/get_benchmark_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Benchmark Dataset Summary — get_benchmark_summary","text":"","code":"get_benchmark_summary(dataset_name)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/get_benchmark_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Benchmark Dataset Summary — get_benchmark_summary","text":"dataset_name Character string specifying dataset summarize","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/get_benchmark_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Benchmark Dataset Summary — get_benchmark_summary","text":"list summary information dataset","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/get_benchmark_summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Benchmark Dataset Summary — get_benchmark_summary","text":"","code":"# Get summary of a specific dataset summary_info <- get_benchmark_summary(\"BM_Canonical_HighSNR\") print(summary_info) #> $description #> [1] \"Canonical HRF (SPMG1), high SNR, 3 conditions, fixed amplitudes per condition\" #>  #> $dimensions #> $dimensions$n_timepoints #> [1] 150 #>  #> $dimensions$n_voxels #> [1] 100 #>  #> $dimensions$n_events #> [1] 45 #>  #> $dimensions$n_conditions #> [1] 3 #>  #>  #> $experimental_design #> $experimental_design$conditions #> [1] \"Cond1\" \"Cond2\" \"Cond3\" #>  #> $experimental_design$events_per_condition #> $experimental_design$events_per_condition$Cond1 #> [1] 15 #>  #> $experimental_design$events_per_condition$Cond2 #> [1] 15 #>  #> $experimental_design$events_per_condition$Cond3 #> [1] 15 #>  #>  #> $experimental_design$TR #> [1] 2 #>  #> $experimental_design$total_time #> [1] 300 #>  #> $experimental_design$target_snr #> [1] 4 #>  #>  #> $hrf_information #> $hrf_information$type #> [1] \"SPMG1\" #>  #> $hrf_information$hrf_object_name #> [1] \"HRF_SPMG1\" #>  #> $hrf_information$hrf_object #> function (t, P1 = 5, P2 = 15, A1 = 0.0833)  #> { #>     ifelse(t < 0, 0, exp(-t) * (A1 * t^P1 - 1.274527e-13 * t^P2)) #> } #> <bytecode: 0x5577b4f50100> #> <environment: namespace:fmrihrf> #> attr(,\"class\") #> [1] \"HRF\"      \"function\" #> attr(,\"name\") #> [1] \"SPMG1\" #> attr(,\"nbasis\") #> [1] 1 #> attr(,\"span\") #> [1] 24 #> attr(,\"param_names\") #> [1] \"P1\" \"P2\" \"A1\" #> attr(,\"params\") #> attr(,\"params\")$P1 #> [1] 5 #>  #> attr(,\"params\")$P2 #> [1] 15 #>  #> attr(,\"params\")$A1 #> [1] 0.0833 #>  #>  #>  #> $noise_information #> $noise_information$noise_type #> [1] \"ar1\" #>  #> $noise_information$noise_ar #> [1] 0.4 #>  #> $noise_information$noise_sd #> [1] 0.5217219 #>  #>"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/get_formula.html","id":null,"dir":"Reference","previous_headings":"","what":"Model Utilities for fmri_model Objects — get_formula.fmri_model","title":"Model Utilities for fmri_model Objects — get_formula.fmri_model","text":"Functions creating manipulating fmri_model objects","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/get_formula.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Model Utilities for fmri_model Objects — get_formula.fmri_model","text":"","code":"# S3 method for class 'fmri_model' get_formula(x, ...)  # S3 method for class 'fmri_model' get_formula(x, ...)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/glm_lss.html","id":null,"dir":"Reference","previous_headings":"","what":"GLM LSS Estimation Convenience Function (Single Trial Estimation) — glm_lss","title":"GLM LSS Estimation Convenience Function (Single Trial Estimation) — glm_lss","text":"convenience wrapper around estimate_betas least squares separate (LSS) estimation. primarily designed single trial estimation, individual trial/event gets separate beta estimate rather averaging across trials condition.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/glm_lss.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GLM LSS Estimation Convenience Function (Single Trial Estimation) — glm_lss","text":"","code":"glm_lss(   dataset,   model_obj,   basis_obj,   basemod = NULL,   block = ~1,   use_cpp = TRUE,   progress = TRUE,   ... )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/glm_lss.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GLM LSS Estimation Convenience Function (Single Trial Estimation) — glm_lss","text":"dataset matrix_dataset object containing fMRI time series data model_obj event_model object specifying experimental design basis_obj HRF basis object (e.g., fmrihrf::HRF_SPMG1, HRF_FIR, etc.) basemod baseline_model instance regress data beta estimation (default: NULL) block formula specifying block factor (default: ~ 1 single block) use_cpp Logical; whether use C++ implementation speed (default: TRUE) progress Logical; show progress bar (default: TRUE) ... Additional arguments passed estimate_betas","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/glm_lss.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"GLM LSS Estimation Convenience Function (Single Trial Estimation) — glm_lss","text":"list class \"fmri_betas\" containing estimated trial-wise coefficients","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/glm_lss.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"GLM LSS Estimation Convenience Function (Single Trial Estimation) — glm_lss","text":"Primary Use Case - Single Trial Estimation: Trial-wise beta estimation: trial gets beta coefficient Single trial analysis: Useful decoding, representational similarity analysis (RSA) Trial--trial variability: Captures individual trial responses rather condition averages Avoiding trial averaging: Preserves trial-specific information lost standard GLM Method Details: LSS (Least Squares Separate) fits separate model trial, trial interest gets regressor trials condition modeled together. approach avoids collinearity issues arise including separate regressors every trial simultaneously. standard condition-level estimation (averaging trials within conditions), use glm_ols() instead.","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/glm_lss.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"GLM LSS Estimation Convenience Function (Single Trial Estimation) — glm_lss","text":"","code":"if (FALSE) { # \\dontrun{ # Create event model and data event_data <- data.frame(   onset = c(10, 30, 50, 70),   condition = factor(c(\"A\", \"B\", \"A\", \"B\")),   run = rep(1, 4) ) sframe <- fmrihrf::sampling_frame(blocklens = 100, TR = 2) model_obj <- event_model(onset ~ hrf(condition),                          data = event_data,                          block = ~ run,                          sampling_frame = sframe)  # Create data matrix (100 timepoints, 10 voxels) Y <- matrix(rnorm(1000), 100, 10)  # Create matrix_dataset with event table dset <- matrix_dataset(Y, TR = 2, run_length = 100, event_table = event_data)  # Fit with LSS - estimates separate beta for each individual trial fit <- glm_lss(dset, model_obj, fmrihrf::HRF_SPMG1) dim(fit$betas_ran)  # 4 trials x 10 voxels (NOT averaged by condition)  # This is useful for: # - Decoding analysis (predicting condition from single trial patterns) # - RSA (representational similarity analysis) # - Studying trial-by-trial variability } # }"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/glm_ols.html","id":null,"dir":"Reference","previous_headings":"","what":"GLM OLS Estimation Convenience Function — glm_ols","title":"GLM OLS Estimation Convenience Function — glm_ols","text":"convenience wrapper around estimate_betas ordinary least squares (OLS) estimation. function provides simplified interface fitting GLMs using OLS matrix datasets.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/glm_ols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GLM OLS Estimation Convenience Function — glm_ols","text":"","code":"glm_ols(   dataset,   model_obj,   basis_obj,   basemod = NULL,   block = ~1,   progress = TRUE,   ... )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/glm_ols.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GLM OLS Estimation Convenience Function — glm_ols","text":"dataset matrix_dataset object containing fMRI time series data model_obj event_model object specifying experimental design basis_obj HRF basis object (e.g., fmrihrf::HRF_SPMG1, HRF_FIR, etc.) basemod baseline_model instance regress data beta estimation (default: NULL) block formula specifying block factor (default: ~ 1 single block) progress Logical; show progress bar (default: TRUE) ... Additional arguments passed estimate_betas","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/glm_ols.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"GLM OLS Estimation Convenience Function — glm_ols","text":"list class \"fmri_betas\" containing estimated coefficients","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/glm_ols.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"GLM OLS Estimation Convenience Function — glm_ols","text":"Use Cases: Condition-level estimation: Estimates average responses experimental condition General linear modeling: Standard GLM approach group-level condition-level effects Multi-trial averaging: Combines trials condition estimate mean responses single-trial estimation trial gets beta estimate, use glm_lss() instead.","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/glm_ols.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"GLM OLS Estimation Convenience Function — glm_ols","text":"","code":"if (FALSE) { # \\dontrun{ # Create event model and data event_data <- data.frame(   onset = c(10, 30, 50, 70),   condition = factor(c(\"A\", \"B\", \"A\", \"B\")),   run = rep(1, 4) ) sframe <- fmrihrf::sampling_frame(blocklens = 100, TR = 2) model_obj <- event_model(onset ~ hrf(condition),                          data = event_data,                          block = ~ run,                          sampling_frame = sframe)  # Create data matrix (100 timepoints, 10 voxels) Y <- matrix(rnorm(1000), 100, 10)  # Create matrix_dataset with event table dset <- matrix_dataset(Y, TR = 2, run_length = 100, event_table = event_data)  # Fit with OLS - estimates average response for each condition fit <- glm_ols(dset, model_obj, fmrihrf::HRF_SPMG1) dim(fit$betas_ran)  # 2 conditions x 10 voxels } # }"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/hrf_smoothing_kernel.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute an HRF smoothing kernel — hrf_smoothing_kernel","title":"Compute an HRF smoothing kernel — hrf_smoothing_kernel","text":"function computes temporal similarity matrix series hemodynamic response functions.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/hrf_smoothing_kernel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute an HRF smoothing kernel — hrf_smoothing_kernel","text":"","code":"hrf_smoothing_kernel(   len,   TR = 2,   form = onset ~ trialwise(),   buffer_scans = 3L,   normalise = TRUE,   method = c(\"gram\", \"cosine\") )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/hrf_smoothing_kernel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute an HRF smoothing kernel — hrf_smoothing_kernel","text":"len number scans. TR repetition time (default 2 seconds). form trialwise formula expression, see examples. buffer_scans number scans buffer event. normalise Whether normalise kernel. method method use computing kernel.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/hrf_smoothing_kernel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute an HRF smoothing kernel — hrf_smoothing_kernel","text":"smoothing matrix","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/hrf_smoothing_kernel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute an HRF smoothing kernel — hrf_smoothing_kernel","text":"","code":"form <- onsets ~ trialwise(basis=\"gaussian\") sk <- hrf_smoothing_kernel(100, TR=1.5, form) #> Error: Onset variable 'onsets' extracted from formula LHS is not numeric (class: function)."},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/list_benchmark_datasets.html","id":null,"dir":"Reference","previous_headings":"","what":"List Available Benchmark Datasets — list_benchmark_datasets","title":"List Available Benchmark Datasets — list_benchmark_datasets","text":"Returns summary available benchmark datasets descriptions.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/list_benchmark_datasets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List Available Benchmark Datasets — list_benchmark_datasets","text":"","code":"list_benchmark_datasets()"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/list_benchmark_datasets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List Available Benchmark Datasets — list_benchmark_datasets","text":"data.frame dataset names descriptions","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/list_benchmark_datasets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"List Available Benchmark Datasets — list_benchmark_datasets","text":"","code":"# See what benchmark datasets are available list_benchmark_datasets() #>                                                         Dataset #> BM_Canonical_HighSNR                       BM_Canonical_HighSNR #> BM_Canonical_LowSNR                         BM_Canonical_LowSNR #> BM_HRF_Variability_AcrossVoxels BM_HRF_Variability_AcrossVoxels #> BM_Trial_Amplitude_Variability   BM_Trial_Amplitude_Variability #> BM_Complex_Realistic                       BM_Complex_Realistic #>                                                                                                                        Description #> BM_Canonical_HighSNR                                 Canonical HRF (SPMG1), high SNR, 3 conditions, fixed amplitudes per condition #> BM_Canonical_LowSNR                                   Canonical HRF (SPMG1), low SNR, 3 conditions, fixed amplitudes per condition #> BM_HRF_Variability_AcrossVoxels                                         HRF varies across voxel groups, 2 conditions, moderate SNR #> BM_Trial_Amplitude_Variability                              Single condition with significant trial-to-trial amplitude variability #> BM_Complex_Realistic            Complex realistic scenario: 3 HRF groups, 3 conditions, variable durations/amplitudes, AR(2) noise"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/load_benchmark_dataset.html","id":null,"dir":"Reference","previous_headings":"","what":"Load fMRI Benchmark Datasets — load_benchmark_dataset","title":"Load fMRI Benchmark Datasets — load_benchmark_dataset","text":"function provides easy access benchmark datasets included fmrireg package. datasets designed testing HRF fitting, beta estimation, fMRI analysis methods.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/load_benchmark_dataset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load fMRI Benchmark Datasets — load_benchmark_dataset","text":"","code":"load_benchmark_dataset(dataset_name = \"BM_Canonical_HighSNR\")"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/load_benchmark_dataset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Load fMRI Benchmark Datasets — load_benchmark_dataset","text":"dataset_name Character string specifying dataset load. Options include: \"BM_Canonical_HighSNR\": Canonical HRF high SNR (3 conditions) \"BM_Canonical_LowSNR\": Canonical HRF low SNR (3 conditions) \"BM_HRF_Variability_AcrossVoxels\": HRF varies across voxel groups (2 conditions) \"BM_Trial_Amplitude_Variability\": Trial--trial amplitude variability (1 condition) \"BM_Complex_Realistic\": Complex scenario multiple factors (3 conditions) \"\": Returns datasets list \"metadata\": Returns metadata datasets","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/load_benchmark_dataset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load fMRI Benchmark Datasets — load_benchmark_dataset","text":"list containing specified benchmark dataset(s) following components: description: Text description dataset Y_noisy: Matrix noisy BOLD time series (time x voxels) Y_clean: Matrix clean BOLD time series (available) X_list_true_hrf: List design matrices convolved true HRF true_hrf_parameters: Information true HRF(s) used event_onsets: Vector event onset times condition_labels: Vector condition labels event true_betas_condition: Matrix true condition-level beta values true_amplitudes_trial: Matrix true trial-level amplitudes TR: Repetition time total_time: Total scan duration noise_parameters: Information noise generation simulation_seed: Random seed used generation target_snr: Target signal--noise ratio","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/load_benchmark_dataset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Load fMRI Benchmark Datasets — load_benchmark_dataset","text":"","code":"# Load a specific dataset high_snr_data <- load_benchmark_dataset(\"BM_Canonical_HighSNR\")  # Get information about all available datasets metadata <- load_benchmark_dataset(\"metadata\")  # Load all datasets all_data <- load_benchmark_dataset(\"all\")  # Access the BOLD data Y <- high_snr_data$Y_noisy  # Get event information onsets <- high_snr_data$event_onsets conditions <- high_snr_data$condition_labels"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/longnames.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Long Names of Variable Levels — longnames","title":"Extract Long Names of Variable Levels — longnames","text":"Get extended names variable levels, include term prefix basis function information. Long names provide complete specification condition model. example, term conditions \"level1\" \"level2\" basis functions \"basis1\" \"basis2\", long names \"term#level1:basis1\", \"term#level1:basis2\", \"term#level2:basis1\", \"term#level2:basis2\".","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/longnames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Long Names of Variable Levels — longnames","text":"","code":"longnames(x, ...)  # S3 method for class 'event_term' longnames(x, ...)  # S3 method for class 'event_seq' longnames(x, ...)  # S3 method for class 'convolved_term' longnames(x, ...)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/longnames.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Long Names of Variable Levels — longnames","text":"x object extract names (typically event_term, event_model, convolved_term) ... Additional arguments passed methods. Common arguments include: exclude_basis Logical; TRUE, exclude basis function labels names drop_empty Logical; TRUE, drop empty condition levels","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/longnames.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Long Names of Variable Levels — longnames","text":"character vector containing full condition names term prefixes basis functions","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/longnames.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Long Names of Variable Levels — longnames","text":"","code":"# Create example data with multiple conditions event_data <- data.frame(   condition = factor(c(\"A\", \"B\", \"C\", \"A\", \"B\", \"C\")),   rt = c(0.8, 1.2, 0.9, 1.1, 0.7, 1.3),   onsets = c(1, 10, 20, 30, 40, 50),   run = c(1, 1, 1, 1, 1, 1) )  # Create sampling frame sframe <- sampling_frame(blocklens = 60, TR = 2)  # Create event model with multiple basis functions evmodel <- event_model(   onsets ~ hrf(condition, basis = \"fourier\", nbasis = 2),   data = event_data,   block = ~run,   sampling_frame = sframe )  # Get long names including basis functions lnames <- longnames(evmodel) #> Error in UseMethod(\"longnames\"): no applicable method for 'longnames' applied to an object of class \"c('event_model', 'list')\" # Returns: c(\"condition#A:basis1\", \"condition#A:basis2\", #           \"condition#B:basis1\", \"condition#B:basis2\", #           \"condition#C:basis1\", \"condition#C:basis2\")  # Create simple event term eterm <- event_term(   list(condition = event_data$condition),   onsets = event_data$onsets,   blockids = event_data$run )  # Get long names for term term_names <- longnames(eterm) # Returns: c(\"condition#A\", \"condition#B\", \"condition#C\")"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/mixed_solve_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Mixed Model Solver using Rcpp and roptim — mixed_solve_cpp","title":"Mixed Model Solver using Rcpp and roptim — mixed_solve_cpp","text":"function solves mixed model using Rcpp roptim optimization. estimates variance components mixed model, potentially speeding computations compared pure R implementation.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/mixed_solve_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mixed Model Solver using Rcpp and roptim — mixed_solve_cpp","text":"","code":"mixed_solve_cpp(   y,   Z = NULL,   K = NULL,   X = NULL,   method = \"REML\",   bounds = c(1e-09, 1e+09),   SE = FALSE,   return_Hinv = FALSE )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/mixed_solve_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mixed Model Solver using Rcpp and roptim — mixed_solve_cpp","text":"y Response vector. Z Design matrix random effects (default: identity matrix size n). K Kinship matrix (default: NULL). X Design matrix fixed effects (default: vector ones). method Optimization method, either \"REML\" \"ML\" (default: \"REML\"). bounds Bounds optimizer (default: c(1e-9, 1e9)). SE Logical, whether return standard errors (default: FALSE). return_Hinv Logical, whether return inverse H (default: FALSE).","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/mixed_solve_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mixed Model Solver using Rcpp and roptim — mixed_solve_cpp","text":"list containing: Vu Estimated variance component random effects. Ve Estimated variance component residuals. beta Estimated fixed effects coefficients. u Estimated random effects coefficients. LL Log-likelihood model. beta.SE Standard errors fixed effects coefficients (SE = TRUE). u.SE Standard errors random effects coefficients (SE = TRUE). Hinv Inverse H (return_Hinv = TRUE).","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/mixed_solve_cpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mixed Model Solver using Rcpp and roptim — mixed_solve_cpp","text":"","code":"if (FALSE) { # \\dontrun{ # Example usage with random data set.seed(123) n <- 100 y <- rnorm(n) Z <- matrix(rnorm(n * 5), n, 5) K <- diag(5) X <- matrix(1, n, 1) result <- mixed_solve_cpp(y, Z, K, X) } # }"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/multiresponse_bootstrap_lm.html","id":null,"dir":"Reference","previous_headings":"","what":"Multiresponse bootstrap linear model — multiresponse_bootstrap_lm","title":"Multiresponse bootstrap linear model — multiresponse_bootstrap_lm","text":"Performs block bootstrap resampling multiresponse linear models, particularly useful fMRI time series data temporal dependencies exist. function implements block bootstrap approach maintain temporal correlation structure within data.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/multiresponse_bootstrap_lm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multiresponse bootstrap linear model — multiresponse_bootstrap_lm","text":"","code":"multiresponse_bootstrap_lm(   form,   data_env,   conlist,   vnames,   fcon,   modmat = NULL,   block_size = 30,   boot_rows = FALSE,   nboot = 100,   event_indices )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/multiresponse_bootstrap_lm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multiresponse bootstrap linear model — multiresponse_bootstrap_lm","text":"form Formula linear model. Required modmat NULL. data_env Environment containing data linear model. conlist List contrasts computed bootstrap sample. vnames Vector variable names. fcon Contrasts fixed effects. modmat Optional pre-computed model matrix. provided, form ignored. block_size Size blocks bootstrap (default: 30). large enough capture temporal dependencies small enough allow sufficient randomization. boot_rows Logical flag indicating whether bootstrap rows (default: FALSE). nboot Number bootstrap iterations (default: 100). event_indices Indices events computing beta covariances.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/multiresponse_bootstrap_lm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multiresponse bootstrap linear model — multiresponse_bootstrap_lm","text":"list containing: original: fitted original model contrasts con_cov: Covariance matrices contrasts (contrasts provided) beta_cov: Covariance matrices beta estimates nboot: Number bootstrap iterations performed bootstrap: Logical indicating bootstrap result","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/multiresponse_bootstrap_lm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Multiresponse bootstrap linear model — multiresponse_bootstrap_lm","text":"function performs following steps: Fits original linear model Implements block bootstrap resampling residuals Reconstructs response variables using fitted values resampled residuals Computes contrasts bootstrap sample block bootstrap approach helps preserve temporal dependencies data resampling blocks consecutive observations rather individual observations.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/multiresponse_bootstrap_lm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multiresponse bootstrap linear model — multiresponse_bootstrap_lm","text":"","code":"# \\donttest{ # Simple example with synthetic data X <- model.matrix(~ x1 + x2, data = data.frame(x1 = rnorm(100), x2 = rnorm(100))) y <- matrix(rnorm(100 * 3), 100, 3)  # 3 response variables result <- multiresponse_bootstrap_lm(modmat = X, data_env = list(.y = y),                                     nboot = 100, block_size = 20) #> Error in multiresponse_bootstrap_lm(modmat = X, data_env = list(.y = y),     nboot = 100, block_size = 20): could not find function \"multiresponse_bootstrap_lm\" # }"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/multiresponse_lm.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit Multiresponse Linear Model — multiresponse_lm","title":"Fit Multiresponse Linear Model — multiresponse_lm","text":"function fits linear model multiple responses fMRI dataset.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/multiresponse_lm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit Multiresponse Linear Model — multiresponse_lm","text":"","code":"multiresponse_lm(form, data_env, conlist, vnames, fcon, modmat = NULL)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/multiresponse_lm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit Multiresponse Linear Model — multiresponse_lm","text":"form formula used define linear model. data_env environment containing data used linear model. conlist list contrasts used analysis. vnames names variables used linear model. fcon F-contrasts used analysis. modmat model matrix (default NULL, calculate model matrix using formula).","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/multiresponse_lm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit Multiresponse Linear Model — multiresponse_lm","text":"list containing results multiresponse linear model analysis.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/p_values.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract P-values from a Model Fit — p_values","title":"Extract P-values from a Model Fit — p_values","text":"Extract p-values associated parameter estimates test statistics fitted model object. part family functions extracting statistical measures.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/p_values.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract P-values from a Model Fit — p_values","text":"","code":"p_values(x, ...)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/p_values.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract P-values from a Model Fit — p_values","text":"x fitted model object ... Additional arguments passed methods. Common arguments include: type type p-values extract (e.g., \"estimates\" \"contrasts\")","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/p_values.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract P-values from a Model Fit — p_values","text":"tibble matrix containing p-values","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/p_values.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract P-values from a Model Fit — p_values","text":"","code":"# Create example data event_data <- data.frame(   condition = factor(c(\"A\", \"B\", \"A\", \"B\")),   onsets = c(1, 10, 20, 30),   run = c(1, 1, 1, 1) )  # Create sampling frame and dataset sframe <- sampling_frame(blocklens = 50, TR = 2) dset <- fmridataset::matrix_dataset(   matrix(rnorm(100 * 2), 100, 2),   TR = 2,   run_length = 50,   event_table = event_data ) #> Error: sum(run_length) not equal to nrow(datamat)  # Fit model fit <- fmri_lm(   onsets ~ hrf(condition),   block = ~run,   dataset = dset ) #> Error: object 'dset' not found  # Extract p-values pvals <- p_values(fit) #> Error: object 'fit' not found"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/print.html","id":null,"dir":"Reference","previous_headings":"","what":"Print an fmri_lm_result object — print.fmri_model","title":"Print an fmri_lm_result object — print.fmri_model","text":"Provides colorful informative printout.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/print.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print an fmri_lm_result object — print.fmri_model","text":"","code":"# S3 method for class 'fmri_model' print(x, ...)  # S3 method for class 'fmri_lm' print(x, ...)  # S3 method for class 'fmri_rlm' print(x, ...)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/print.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print an fmri_lm_result object — print.fmri_model","text":"x fmri_rlm object ... Additional arguments passed print.fmri_lm","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/pull_stat_revised.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Statistical Measures from an fmri_lm Object — pull_stat_revised","title":"Extract Statistical Measures from an fmri_lm Object — pull_stat_revised","text":"function extracts statistical measures (e.g., estimates, standard errors) fmri_lm object.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/pull_stat_revised.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Statistical Measures from an fmri_lm Object — pull_stat_revised","text":"","code":"pull_stat_revised(x, type, element)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/pull_stat_revised.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Statistical Measures from an fmri_lm Object — pull_stat_revised","text":"x fmri_lm object. type type statistic extract: \"betas\", \"contrasts\", \"F\". element specific element extract, \"estimate\", \"se\", \"stat\", \"prob\".","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/pull_stat_revised.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Statistical Measures from an fmri_lm Object — pull_stat_revised","text":"tibble containing requested statistical measures.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. fmridataset .matrix_dataset, data_chunks, fmri_dataset, fmri_mem_dataset, get_data, get_data_matrix, get_mask, latent_dataset, matrix_dataset, read_fmri_config fmridesign baseline, baseline_model, baseline_terms, basis_suffix, block, blockids, BSpline, cells, column_contrast, columns, condition_basis_list, conditions, construct, contrast, contrast_weights, convolve, convolve_design, covariate, design_map, design_matrix, durations, elements, event_basis, event_factor, event_matrix, event_model, event_table, event_term, event_terms, event_variable, feature_suffix, hrf, Ident, interaction_contrast, is_categorical, is_continuous, longnames, nuisance, one_against_all_contrast, oneway_contrast, onsets, pair_contrast, plot_contrasts, Poly, poly_contrast, RobustScale, sanitize, Scale, ScaleWithin, shortnames, split_by_block, Standardized, sub_basis, term_indices, term_matrices, trialwise, unit_contrast fmrihrf as_hrf, blockids, blocklens, evaluate, gen_hrf, global_onsets, HRF, hrf_spmg1, nbasis, regressor, samples, sampling_frame","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/reshape_coef.html","id":null,"dir":"Reference","previous_headings":"","what":"Reshape Coefficient Data — reshape_coef","title":"Reshape Coefficient Data — reshape_coef","text":"function reshapes coefficient data wide long format merges design information.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/reshape_coef.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reshape Coefficient Data — reshape_coef","text":"","code":"reshape_coef(df, des, measure = \"value\")"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/reshape_coef.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reshape Coefficient Data — reshape_coef","text":"df data frame containing coefficient estimates. des data frame containing design information. measure name value column reshaped data. Default \"value\".","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/reshape_coef.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reshape Coefficient Data — reshape_coef","text":"data frame long format merged design information.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/runwise_lm.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform Runwise Linear Modeling on fMRI Dataset — runwise_lm","title":"Perform Runwise Linear Modeling on fMRI Dataset — runwise_lm","text":"function performs runwise linear model analysis fMRI dataset, running linear model run separately pooling results. function performs runwise linear model analysis fMRI dataset running linear model data run combining results.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/runwise_lm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform Runwise Linear Modeling on fMRI Dataset — runwise_lm","text":"","code":"runwise_lm(   dset,   model,   contrast_objects,   cfg,   verbose = FALSE,   use_fast_path = FALSE,   progress = FALSE,   phi_fixed = NULL,   sigma_fixed = NULL,   parallel_voxels = FALSE )  runwise_lm(   dset,   model,   contrast_objects,   cfg,   verbose = FALSE,   use_fast_path = FALSE,   progress = FALSE,   phi_fixed = NULL,   sigma_fixed = NULL,   parallel_voxels = FALSE )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/runwise_lm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform Runwise Linear Modeling on fMRI Dataset — runwise_lm","text":"dset fmri_dataset object. model fmri_model used analysis. contrast_objects list full contrast objects. cfg fmri_lm_config object containing fitting options. verbose Logical. Whether display progress messages (default FALSE). use_fast_path Logical. Whether use fast path computation (default FALSE). progress Logical. Display progress bar run processing. Default FALSE. phi_fixed Optional fixed AR parameters. sigma_fixed Optional fixed robust scale estimate. parallel_voxels Logical. TRUE, process voxels parallel using future.apply. Default FALSE.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/runwise_lm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform Runwise Linear Modeling on fMRI Dataset — runwise_lm","text":"list containing combined results runwise linear model analysis. list containing combined results runwise linear model analysis.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/sandwich_variance.html","id":null,"dir":"Reference","previous_headings":"","what":"Sandwich Variance Estimation in fmrireg — sandwich_variance","title":"Sandwich Variance Estimation in fmrireg — sandwich_variance","text":"documentation describes sandwich variance estimation capabilities fmrireg, provide robust standard errors regression coefficients model assumptions violated.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/sandwich_variance.html","id":"background","dir":"Reference","previous_headings":"","what":"Background","title":"Sandwich Variance Estimation in fmrireg — sandwich_variance","text":"sandwich variance estimator (also known Huber-White estimator) provides valid standard errors even residuals exhibit heteroscedasticity violations classical linear model assumptions.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/sandwich_variance.html","id":"mathematical-details","dir":"Reference","previous_headings":"","what":"Mathematical Details","title":"Sandwich Variance Estimation in fmrireg — sandwich_variance","text":"sandwich estimator computed : $$V_{sandwich} = (X'X)^{-1} X' \\Omega X (X'X)^{-1}$$ \\(\\Omega\\) diagonal matrix squared residuals diagonal. robust regression weights \\(w_i\\), weighted version : $$V_{sandwich} = (X'WX)^{-1} X'W \\Omega WX (X'WX)^{-1}$$","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/sandwich_variance.html","id":"usage-in-fmrireg","dir":"Reference","previous_headings":"","what":"Usage in fmrireg","title":"Sandwich Variance Estimation in fmrireg — sandwich_variance","text":"Sandwich variance estimation automatically used : Robust regression enabled (using M-estimators) AR modeling combined robust regression Heteroscedasticity suspected residuals","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/sandwich_variance.html","id":"effective-degrees-of-freedom","dir":"Reference","previous_headings":"","what":"Effective Degrees of Freedom","title":"Sandwich Variance Estimation in fmrireg — sandwich_variance","text":"using robust regression /AR models, effective degrees freedom adjusted account : Downweighting outliers robust regression Loss degrees freedom due AR parameter estimation adjustment formula : $$df_{effective} = df_{base} \\times \\frac{\\sum w_i}{n} \\times \\frac{n - p_{AR}}{n}$$","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/sandwich_variance.html","id":"implementation-notes","dir":"Reference","previous_headings":"","what":"Implementation Notes","title":"Sandwich Variance Estimation in fmrireg — sandwich_variance","text":"Small sample corrections applied (n/(n-p) factor) multi-voxel data, computation vectorized efficiency Compatible contrast types (t, F, custom)","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/sandwich_variance.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Sandwich Variance Estimation in fmrireg — sandwich_variance","text":"Huber, P. J. (1967). behavior maximum likelihood estimates nonstandard conditions. Proceedings Fifth Berkeley Symposium Mathematical Statistics Probability. White, H. (1980). heteroskedasticity-consistent covariance matrix estimator direct test heteroskedasticity. Econometrica, 48(4), 817-838.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/sandwich_variance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sandwich Variance Estimation in fmrireg — sandwich_variance","text":"","code":"if (FALSE) { # \\dontrun{ # Fit model with robust regression cfg <- fmri_lm_control(   robust = list(     type = \"bisquare\",     c_tukey = 4.685   ) )  fit <- fmri_lm(model, dataset, config = cfg)  # Standard errors in fit$betas will use sandwich variance # P-values will use effective degrees of freedom } # }"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/shortnames.html","id":null,"dir":"Reference","previous_headings":"","what":"Short Names — shortnames","title":"Short Names — shortnames","text":"Generate short names model terms conditions.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/shortnames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Short Names — shortnames","text":"","code":"shortnames(x, ...)  # S3 method for class 'event_term' shortnames(x, ...)  # S3 method for class 'event_model' shortnames(x, ...)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/shortnames.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Short Names — shortnames","text":"x object generate short names . ... Additional arguments.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/shortnames.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Short Names — shortnames","text":"character vector short names.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/simulate_bold_signal.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate fMRI Time Series — simulate_bold_signal","title":"Simulate fMRI Time Series — simulate_bold_signal","text":"function simulates fMRI time series multiple experimental conditions specified parameters. generates realistic event-related design randomized inter-stimulus intervals condition orders.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/simulate_bold_signal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate fMRI Time Series — simulate_bold_signal","text":"","code":"simulate_bold_signal(   ncond,   hrf = fmrihrf::HRF_SPMG1,   nreps = 12,   amps = rep(1, ncond),   isi = c(3, 6),   ampsd = 0,   TR = 1.5 )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/simulate_bold_signal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate fMRI Time Series — simulate_bold_signal","text":"ncond number conditions simulate. hrf hemodynamic response function use (default fmrihrf::HRF_SPMG1). nreps number repetitions per condition (default 12). amps vector amplitudes condition (default vector 1s length ncond). isi vector length 2 specifying range inter-stimulus intervals sample (default c(3, 6) seconds). ampsd standard deviation amplitudes (default 0). TR repetition time fMRI acquisition (default 1.5 seconds).","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/simulate_bold_signal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate fMRI Time Series — simulate_bold_signal","text":"list following components: onset: vector onset times trial condition: vector condition labels trial mat: matrix containing simulated fMRI time series: Column 1: Time points (seconds) Columns 2:(ncond+1): Simulated BOLD responses condition","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/simulate_bold_signal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate fMRI Time Series — simulate_bold_signal","text":"","code":"# Simulate 3 conditions with different amplitudes sim <- simulate_bold_signal(ncond = 3, amps = c(1, 1.5, 2), TR = 2)  # Plot the simulated time series matplot(sim$mat[,1], sim$mat[,-1], type = \"l\",          xlab = \"Time (s)\", ylab = \"BOLD Response\")"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/simulate_fmri_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate multiple fMRI time series with column-specific parameters — simulate_fmri_matrix","title":"Simulate multiple fMRI time series with column-specific parameters — simulate_fmri_matrix","text":"Generate multiple fMRI time series column can different amplitude duration parameters drawn specified distributions.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/simulate_fmri_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate multiple fMRI time series with column-specific parameters — simulate_fmri_matrix","text":"","code":"simulate_fmri_matrix(   n = 1,   total_time = 240,   TR = 2,   hrf = fmrihrf::HRF_SPMG1,   n_events = 10,   onsets = NULL,   isi_dist = c(\"even\", \"uniform\", \"exponential\"),   isi_min = 2,   isi_max = 6,   isi_rate = 0.25,   durations = 0,   duration_sd = 0,   duration_dist = c(\"lognormal\", \"gamma\"),   amplitudes = 1,   amplitude_sd = 0,   amplitude_dist = c(\"lognormal\", \"gamma\", \"gaussian\"),   single_trial = FALSE,   noise_type = c(\"none\", \"white\", \"ar1\", \"ar2\"),   noise_ar = NULL,   noise_sd = 1,   random_seed = NULL,   verbose = FALSE,   buffer = 16 )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/simulate_fmri_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate multiple fMRI time series with column-specific parameters — simulate_fmri_matrix","text":"n Number time-series (columns). total_time Total scan length (seconds). TR Repetition time (seconds). hrf Hemodynamic response function, e.g. fmrihrf::HRF_SPMG1. n_events Number events. onsets Optional numeric vector event onsets. isi_dist Inter-stimulus interval distribution. isi_min, isi_max ISI range uniform distribution. isi_rate Rate exponential distribution. durations Event durations. duration_sd Standard deviation duration sampling. duration_dist Distribution duration sampling. amplitudes Event amplitudes. amplitude_sd Standard deviation amplitude sampling. amplitude_dist Distribution amplitude sampling. single_trial Whether use single-trial regressors. noise_type Type noise add. noise_ar AR coefficients noise. noise_sd Noise standard deviation. random_seed Random seed reproducibility. verbose Whether print messages.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/simulate_fmri_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate multiple fMRI time series with column-specific parameters — simulate_fmri_matrix","text":"list time_series (matrix_dataset), ampmat, durmat, hrf_info, noise_params.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/simulate_noise_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate fMRI Noise — simulate_noise_vector","title":"Simulate fMRI Noise — simulate_noise_vector","text":"function simulates realistic fMRI noise combining: Temporal autocorrelation using ARMA model Low-frequency drift Physiological noise (cardiac respiratory)","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/simulate_noise_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate fMRI Noise — simulate_noise_vector","text":"","code":"simulate_noise_vector(   n,   TR = 1.5,   ar = c(0.3),   ma = c(0.5),   sd = 1,   drift_freq = 1/128,   drift_amplitude = 2,   physio = TRUE,   seed = NULL )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/simulate_noise_vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate fMRI Noise — simulate_noise_vector","text":"n number time points fMRI time series TR repetition time seconds (default 1.5) ar numeric vector containing autoregressive (AR) coefficients (default c(0.3)) ma numeric vector containing moving average (MA) coefficients (default c(0.5)) sd standard deviation white noise component (default 1) drift_freq Frequency low-frequency drift Hz (default 1/128) drift_amplitude Amplitude low-frequency drift (default 2) physio Logical; whether add simulated physiological noise (default TRUE) seed optional seed reproducibility (default NULL)","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/simulate_noise_vector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate fMRI Noise — simulate_noise_vector","text":"numeric vector containing simulated fMRI noise","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/simulate_noise_vector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate fMRI Noise — simulate_noise_vector","text":"","code":"# Simulate noise for a 5-minute scan with TR=2s n_timepoints <- 150  # 5 minutes * 60 seconds / 2s TR noise <- simulate_noise_vector(n_timepoints, TR = 2) plot(noise, type = \"l\", xlab = \"Time Point\", ylab = \"Signal\")"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/simulate_simple_dataset.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Complete fMRI Dataset — simulate_simple_dataset","title":"Simulate Complete fMRI Dataset — simulate_simple_dataset","text":"function simulates complete fMRI dataset combining task-related signals realistic noise. returns clean signals noisy data.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/simulate_simple_dataset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Complete fMRI Dataset — simulate_simple_dataset","text":"","code":"simulate_simple_dataset(   ncond,   nreps = 12,   TR = 1.5,   snr = 0.5,   hrf = fmrihrf::HRF_SPMG1,   seed = NULL )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/simulate_simple_dataset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Complete fMRI Dataset — simulate_simple_dataset","text":"ncond Number conditions simulate nreps Number repetitions per condition (default 12) TR Repetition time seconds (default 1.5) snr Signal--noise ratio (default 0.5) hrf Hemodynamic response function use (default fmrihrf::HRF_SPMG1) seed Optional seed reproducibility (default NULL)","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/simulate_simple_dataset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Complete fMRI Dataset — simulate_simple_dataset","text":"list containing: clean: simulated signals without noise (simulate_bold_signal) noisy: signals added noise noise: simulated noise component onsets: Trial onset times conditions: Condition labels trial","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/simulate_simple_dataset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Complete fMRI Dataset — simulate_simple_dataset","text":"","code":"# Simulate a dataset with 3 conditions data <- simulate_simple_dataset(ncond = 3, TR = 2, snr = 0.5)  # Plot clean and noisy data par(mfrow = c(2,1)) matplot(data$clean$mat[,1], data$clean$mat[,-1], type = \"l\",         main = \"Clean Signal\", xlab = \"Time (s)\", ylab = \"BOLD\") matplot(data$noisy[,1], data$noisy[,-1], type = \"l\",         main = \"Noisy Signal\", xlab = \"Time (s)\", ylab = \"BOLD\")"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/standard_error.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Standard Errors from a Model Fit — standard_error","title":"Extract Standard Errors from a Model Fit — standard_error","text":"Extract standard errors parameter estimates fitted model object. part family functions extracting statistical measures.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/standard_error.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Standard Errors from a Model Fit — standard_error","text":"","code":"standard_error(x, ...)  # S3 method for class 'fmri_latent_lm' standard_error(x, type = c(\"estimates\", \"contrasts\"), recon = FALSE, ...)  # S3 method for class 'fmri_lm' standard_error(x, type = c(\"estimates\", \"contrasts\"), ...)  # S3 method for class 'fmri_lm' standard_error(x, type = c(\"estimates\", \"contrasts\"), ...)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/standard_error.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Standard Errors from a Model Fit — standard_error","text":"x fitted model object ... Additional arguments passed methods type type standard errors extract: \"estimates\" \"contrasts\" (default: \"estimates\") recon Logical; whether reconstruct full matrix representation (default: FALSE)","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/standard_error.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Standard Errors from a Model Fit — standard_error","text":"tibble matrix containing standard errors parameter estimates","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/standard_error.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Standard Errors from a Model Fit — standard_error","text":"","code":"# Create example data event_data <- data.frame(   condition = factor(c(\"A\", \"B\", \"A\", \"B\")),   onsets = c(1, 10, 20, 30),   run = c(1, 1, 1, 1) )  # Create sampling frame and dataset sframe <- sampling_frame(blocklens = 50, TR = 2) dset <- fmridataset::matrix_dataset(   matrix(rnorm(100 * 2), 100, 2),   TR = 2,   run_length = 50,   event_table = event_data ) #> Error: sum(run_length) not equal to nrow(datamat)  # Fit model fit <- fmri_lm(   onsets ~ hrf(condition),   block = ~run,   dataset = dset ) #> Error: object 'dset' not found  # Extract standard errors se <- standard_error(fit) #> Error: object 'fit' not found"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/stats.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Test Statistics from a Model Fit — stats","title":"Extract Test Statistics from a Model Fit — stats","text":"Extract test statistics (e.g., t-statistics, F-statistics) fitted model object. part family functions extracting statistical measures.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/stats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Test Statistics from a Model Fit — stats","text":"","code":"stats(x, ...)  # S3 method for class 'fmri_lm' stats(x, type = c(\"estimates\", \"contrasts\", \"F\"), ...)  # S3 method for class 'fmri_lm' stats(x, type = c(\"estimates\", \"contrasts\", \"F\"), ...)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/stats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Test Statistics from a Model Fit — stats","text":"x fitted model object ... Additional arguments passed methods type type statistics extract: \"estimates\", \"contrasts\", \"F\" (default: \"estimates\")","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/stats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Test Statistics from a Model Fit — stats","text":"tibble matrix containing test statistics","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/stats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Test Statistics from a Model Fit — stats","text":"","code":"# Create example data event_data <- data.frame(   condition = factor(c(\"A\", \"B\", \"A\", \"B\")),   onsets = c(1, 10, 20, 30),   run = c(1, 1, 1, 1) )  # Create sampling frame and dataset sframe <- sampling_frame(blocklens = 50, TR = 2) dset <- fmridataset::matrix_dataset(   matrix(rnorm(100 * 2), 100, 2),   TR = 2,   run_length = 50,   event_table = event_data ) #> Error: sum(run_length) not equal to nrow(datamat)  # Fit model fit <- fmri_lm(   onsets ~ hrf(condition),   block = ~run,   dataset = dset ) #> Error: object 'dset' not found  # Extract test statistics tstats <- stats(fit) #> Error: object 'fit' not found"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/term_matrices.fmri_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract term matrices from fmri_model — term_matrices.fmri_model","title":"Extract term matrices from fmri_model — term_matrices.fmri_model","text":"Extract design matrices individual terms fmri_model object.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/term_matrices.fmri_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract term matrices from fmri_model — term_matrices.fmri_model","text":"","code":"# S3 method for class 'fmri_model' term_matrices(x, blocknum = NULL, ...)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/term_matrices.fmri_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract term matrices from fmri_model — term_matrices.fmri_model","text":"x fmri_model object blocknum Optional vector block numbers extract matrices ... Additional arguments (currently unused)","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/term_matrices.fmri_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract term matrices from fmri_model — term_matrices.fmri_model","text":"list matrices, one term model","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/write_results.fmri_lm.html","id":null,"dir":"Reference","previous_headings":"","what":"Write Results from fMRI Linear Model — write_results.fmri_lm","title":"Write Results from fMRI Linear Model — write_results.fmri_lm","text":"Exports statistical maps fmri_lm object HDF5 files BIDS-compliant naming JSON metadata sidecars using fmristore LabeledVolumeSet infrastructure.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/write_results.fmri_lm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write Results from fMRI Linear Model — write_results.fmri_lm","text":"","code":"# S3 method for class 'fmri_lm' write_results(   x,   path = NULL,   subject = NULL,   task = NULL,   space = NULL,   desc = \"GLM\",   strategy = c(\"by_stat\", \"by_contrast\"),   save_betas = TRUE,   contrasts = NULL,   contrast_stats = c(\"beta\", \"tstat\", \"pval\", \"se\"),   overwrite = FALSE,   validate_inputs = TRUE,   ... )"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/write_results.fmri_lm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write Results from fMRI Linear Model — write_results.fmri_lm","text":"x fmri_lm object containing fitted model results path Output directory path. NULL, uses current working directory subject Subject identifier (e.g., \"01\", \"1001\"). Required. task Task identifier (e.g., \"nback\", \"rest\"). Required BIDS compliance. space Spatial reference (e.g., \"MNI152NLin2009cAsym\"). Optional recommended. desc Description analysis (default: \"GLM\") strategy Storage strategy: \"by_stat\" (group contrasts statistic) \"by_contrast\" (separate files) save_betas Logical. Save raw regressor betas (default: TRUE) contrasts Character vector contrast names save. NULL saves contrasts contrast_stats Character vector contrast statistics save (default: c(\"beta\", \"tstat\", \"pval\", \"se\")) overwrite Logical. Overwrite existing files (default: FALSE) validate_inputs Logical. Validate fmrilm object structure (default: TRUE) ... Additional arguments passed internal functions","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/write_results.fmri_lm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write Results from fMRI Linear Model — write_results.fmri_lm","text":"Invisible list file paths created","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/write_results.fmri_lm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write Results from fMRI Linear Model — write_results.fmri_lm","text":"","code":"if (FALSE) { # \\dontrun{ # Save all results using default settings write_results(fitted_model, subject = \"01\", task = \"nback\")  # Save only specific contrasts and statistics   write_results(fitted_model,                subject = \"01\", task = \"nback\", space = \"MNI152NLin2009cAsym\",               contrasts = c(\"FacesVsPlaces\", \"GoVsNoGo\"),               contrast_stats = c(\"beta\", \"tstat\")) } # }"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/write_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Write Results from fMRI Analysis — write_results","title":"Write Results from fMRI Analysis — write_results","text":"Generic function export statistical maps analysis results fitted fMRI models standardized file formats appropriate metadata.","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/write_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write Results from fMRI Analysis — write_results","text":"","code":"write_results(x, ...)"},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/write_results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write Results from fMRI Analysis — write_results","text":"x fitted fMRI model object ... Additional arguments passed methods","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/reference/write_results.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write Results from fMRI Analysis — write_results","text":"Invisible list created file paths","code":""},{"path":"https://bbuchsbaum.github.io/fmrireg/news/index.html","id":"fmrireg-001","dir":"Changelog","previous_headings":"","what":"fmrireg 0.0.1","title":"fmrireg 0.0.1","text":"Initial CRAN release.","code":""}]
