---
title: "Friman++: adaptive steerable filtering + GLM"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Friman++ demo}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width=6, fig.height=5, dpi=120)
set.seed(202)
```

This vignette demonstrates the “fixed vs steerable” comparison on a tiny 2D phantom. We mirror the two‑step pipeline (Fig. 2), the temporal α‑transform (Eq. 9), and the Step‑2 x‑change (Eq. 15), and keep inference as a standard GLM.

```{r}
library(fmrireg.cca)
nx <- 48; ny <- 48; T <- 120
spacing <- c(2,2); fwhm <- 6
box <- rep(rep(c(1,0), each=10), length.out=T)

vols <- vector("list", T)
for (t in 1:T) vols[[t]] <- matrix(rnorm(nx*ny, sd=1), nx, ny)
act <- matrix(FALSE, nx, ny); act[20:30, 18:38] <- TRUE
for (t in 1:T) if (box[t]==1) vols[[t]][act] <- vols[[t]][act] + 0.6

# Fixed Gaussian smoothing (baseline)
base <- function(slice) fmrireg.cca:::friman_base_responses_2d(slice, spacing, fwhm)$G0
corr_fixed <- matrix(NA_real_, nx, ny)
for (x in 1:nx) for (y in 1:ny) {
  ts <- vapply(vols, function(z) base(z)[x,y], numeric(1))
  corr_fixed[x,y] <- suppressWarnings(stats::cor(ts, box))
}
image(corr_fixed, main="Fixed Gaussian: corr with boxcar", useRaster=TRUE)

# Friman adaptive (2D, suffstats path with synthetic weights for speed)
V <- nx*ny; mask_lin <- seq_len(V); mask_z <- rep(1L, V)
w_dir   <- matrix(c(0.6, 0.3, 0.1), V, 3, byrow = TRUE)
w_step2 <- matrix(c(0.7, 0.3), V, 2, byrow = TRUE)
acc <- fmrireg.cca:::friman_pass2_xts_sts_2d(vols, spacing, fwhm, cbind(box), w_dir, w_step2, mask_lin, mask_z)
XtX <- matrix(sum(box^2), 1, 1)
beta <- matrix(acc$XtS[1,]/XtX[1,1], nx, ny)
image(beta, main="Steerable 2D: GLM beta (task)", useRaster=TRUE)

roc_auc <- function(score, truth) {
  s <- as.numeric(score); y <- as.integer(truth)
  o <- order(-s); y <- y[o]
  tpr <- cumsum(y)/sum(y); fpr <- cumsum(1-y)/sum(1-y)
  sum(diff(c(0,fpr)) * c(0, head(tpr, -1)))
}
c(AUC_fixed = roc_auc(corr_fixed, act), AUC_steer = roc_auc(beta, act))
```

Notes
- The α‑mix (cca2 basis) defaults to ~0.3; it ensures the mean HRF dominates under non‑negative weights (Eq. 9).
- The adaptive front‑end is linear; we run the same GLM as other fmrireg engines, so contrasts and group‑level are unchanged.
- For 3D isotropic data, expect small gains vs 2D (Fig. 9).

